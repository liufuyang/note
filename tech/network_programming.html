<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Network Programming - Personal notebook</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../note.html"><strong aria-hidden="true">1.</strong> Note</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../note/1.html"><strong aria-hidden="true">1.1.</strong> Note 1</a></li><li class="chapter-item expanded "><a href="../note/todo.html"><strong aria-hidden="true">1.2.</strong> ToDo</a></li></ol></li><li class="chapter-item expanded "><a href="../algorithms/algorithms.html"><strong aria-hidden="true">2.</strong> Algorithms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../algorithms/1.html"><strong aria-hidden="true">2.1.</strong> Big O notations</a></li><li class="chapter-item expanded "><a href="../algorithms/stack_queue.html"><strong aria-hidden="true">2.2.</strong> Stack and Queue</a></li><li class="chapter-item expanded "><a href="../algorithms/devide_conquer.html"><strong aria-hidden="true">2.3.</strong> Divide and Conquer</a></li><li class="chapter-item expanded "><a href="../algorithms/sort.html"><strong aria-hidden="true">2.4.</strong> Sort</a></li><li class="chapter-item expanded "><a href="../algorithms/dynamic_programming.html"><strong aria-hidden="true">2.5.</strong> Dynamic programming</a></li><li class="chapter-item expanded "><a href="../algorithms/a_star_search.html"><strong aria-hidden="true">2.6.</strong> A * Search homework</a></li><li class="chapter-item expanded "><a href="../algorithms/binary_search_tree.html"><strong aria-hidden="true">2.7.</strong> Binary Search Tree</a></li><li class="chapter-item expanded "><a href="../algorithms/balanced_search_tree.html"><strong aria-hidden="true">2.8.</strong> Balanced Search Trees</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../algorithms/balanced_search_tree/red_black_bst.html"><strong aria-hidden="true">2.8.1.</strong> Red-Black BSTs</a></li><li class="chapter-item expanded "><a href="../algorithms/balanced_search_tree/b_tree.html"><strong aria-hidden="true">2.8.2.</strong> B-Trees</a></li><li class="chapter-item expanded "><a href="../algorithms/balanced_search_tree/kd_tree.html"><strong aria-hidden="true">2.8.3.</strong> Kd-Trees</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../rust_note/rust.html"><strong aria-hidden="true">3.</strong> Rust note</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> General</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust_note/general/cpp_memory_model.html"><strong aria-hidden="true">3.1.1.</strong> C++ memory mode</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Note from courses</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust_note/courses/pattern_matching.html"><strong aria-hidden="true">3.2.1.</strong> Pattern matching</a></li><li class="chapter-item expanded "><a href="../rust_note/courses/smart_pointers.html"><strong aria-hidden="true">3.2.2.</strong> Smart pointers</a></li><li class="chapter-item expanded "><a href="../rust_note/courses/string.html"><strong aria-hidden="true">3.2.3.</strong> String</a></li></ol></li><li class="chapter-item expanded "><a href="../rust_note/tokio.html"><strong aria-hidden="true">3.3.</strong> Note for tokio dev</a></li><li class="chapter-item expanded "><a href="../rust_note/resources.html"><strong aria-hidden="true">3.4.</strong> Resources</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Tech notes</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tech/network_programming.html" class="active"><strong aria-hidden="true">4.1.</strong> Network Programming</a></li><li class="chapter-item expanded "><a href="../tech/java/java.html"><strong aria-hidden="true">4.2.</strong> Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tech/java/scheduler.html"><strong aria-hidden="true">4.2.1.</strong> Scheduler stuff</a></li></ol></li><li class="chapter-item expanded "><a href="../tech/cli_tools.html"><strong aria-hidden="true">4.3.</strong> CLI tools</a></li></ol></li><li class="chapter-item expanded "><a href="../prob_and_stats/mit_course/index.html"><strong aria-hidden="true">5.</strong> Probability and Statistics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../prob_and_stats/maths.html"><strong aria-hidden="true">5.1.</strong> Useful maths equations</a></li><li class="chapter-item expanded "><a href="../prob_and_stats/mit_course/chapter_1.html"><strong aria-hidden="true">5.2.</strong> Chapter 1 &amp; 2</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Efficiency Hack</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../efficiency/vi.html"><strong aria-hidden="true">6.1.</strong> üìù Vi editor tips</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Markdown Notes</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../md/md.html"><strong aria-hidden="true">7.1.</strong> Some Markdown Tips</a></li><li class="chapter-item expanded "><a href="../md/details.html"><strong aria-hidden="true">7.2.</strong> &lt;details&gt; usage</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Good Tips</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../sub/life_tips.html"><strong aria-hidden="true">8.1.</strong> Life Tips</a></li><li class="chapter-item expanded "><a href="../sub/career_tips.html"><strong aria-hidden="true">8.2.</strong> Career Tips</a></li></ol></li><li class="chapter-item expanded "><a href="../swedish/index.html"><strong aria-hidden="true">9.</strong> Swedish Learning</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../swedish/shows/huss/huss.html"><strong aria-hidden="true">9.1.</strong> TV Show - Huss</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../swedish/shows/huss/s1a1.html"><strong aria-hidden="true">9.1.1.</strong> S√§song 1 - Avsnitt 1</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Food and Drink</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../food_and_drink/cheese.html"><strong aria-hidden="true">10.1.</strong> Cheese study</a></li><li class="chapter-item expanded "><a href="../food_and_drink/stockholm_restaurants.html"><strong aria-hidden="true">10.2.</strong> Restaurants in Stockholm</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Personal notebook</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/liufuyang/note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="network-programming"><a class="header" href="#network-programming">Network Programming</a></h1>
<p>http://beej.us/guide/bgnet/html/</p>
<h2 id="two-types-of-internet-sockets"><a class="header" href="#two-types-of-internet-sockets">Two Types of Internet Sockets</a></h2>
<ul>
<li><code>SOCK_STREAM</code> -&gt; TCP</li>
<li><code>SOCK_DGRAM</code>-&gt; UDP, may lost, may out of order, but fast</li>
</ul>
<h4 id="layered-network-model-data-encapsulation"><a class="header" href="#layered-network-model-data-encapsulation">Layered Network Model (Data Encapsulation)</a></h4>
<ul>
<li>Application Layer (telnet, ftp, etc.)</li>
<li>Host-to-Host Transport Layer (TCP, UDP) - port number (16-bit number)</li>
<li>Internet Layer (IP and routing)</li>
<li>Network Access Layer (Ethernet, wi-fi, or whatever)</li>
</ul>
<p>See how much work there is in building a simple packet? All you have to do for stream sockets is <code>send()</code> the data out.
All you have to do for <code>datagram sockets</code> is encapsulate the packet in the method of your choosing and <code>sendto()</code> it out. The kernel builds the Transport Layer and Internet Layer on for you and the hardware does the Network Access Layer. Ah, modern technology.</p>
<h3 id="system-calls"><a class="header" href="#system-calls">System calls</a></h3>
<h4 id="bind---what-port-am-i-on"><a class="header" href="#bind---what-port-am-i-on"><code>bind()</code> - What port am I on?</a></h4>
<pre><code class="language-c">struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():
memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

getaddrinfo(NULL, &quot;3490&quot;, &amp;hints, &amp;res);

// make a socket:
sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// bind it to the port we passed in to getaddrinfo():
bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
</code></pre>
<h4 id="connect---hey-you"><a class="header" href="#connect---hey-you"><code>connect()</code> - Hey, you!</a></h4>
<pre><code class="language-c">struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;

getaddrinfo(&quot;www.example.com&quot;, &quot;3490&quot;, &amp;hints, &amp;res);

// make a socket:
sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// connect!
connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
</code></pre>
<p>Also, notice that we didn‚Äôt call <code>bind()</code>. Basically, we don‚Äôt care about our local port number; we only care where we‚Äôre going (the remote port). <strong>The kernel will choose a local port for us</strong>, and the site we connect to will automatically get this information from us. No worries.</p>
<h4 id="listen---keep-on-answering-stuff"><a class="header" href="#listen---keep-on-answering-stuff"><code>listen()</code> - Keep on answering stuff</a></h4>
<pre><code class="language-c">int listen(int sockfd, int backlog);
</code></pre>
<p><code>sockfd</code> is the usual socket file descriptor from the <code>socket()</code> system call. <code>backlog</code> is the number of connections allowed on the incoming queue. What does that mean? Well, incoming connections are going to wait in this queue until you <code>accept()</code> them and this is the limit on how many can queue up. Most systems silently limit this number to about 20; you can probably get away with setting it to 5 or 10.</p>
<p>Well, as you can probably imagine, we need to call <code>bind()</code> before we call <code>listen()</code> so that the server is running on a specific port.</p>
<h4 id="accept---thank-you-for-calling-port-3490"><a class="header" href="#accept---thank-you-for-calling-port-3490"><code>accept()</code> - &quot;Thank you for calling port 3490.&quot;</a></h4>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 
</code></pre>
<p>You call <code>accept()</code> and you tell it to get the pending connection. It‚Äôll return to you a brand new socket file descriptor to use for this single connection! That‚Äôs right, suddenly you have two socket file descriptors for the price of one! The original one is still listening for more new connections, and the newly created one is finally ready to <code>send()</code> and <code>recv()</code></p>
<h4 id="send-and-recv---talk-to-me-baby"><a class="header" href="#send-and-recv---talk-to-me-baby"><code>send()</code> and <code>recv()</code> - Talk to me, baby!</a></h4>
<p>For UDP - <code>sendto()</code> and <code>recvfrom()</code>.</p>
<pre><code class="language-c">int send(int sockfd, const void *msg, int len, int flags); 
</code></pre>
<p>Example:</p>
<pre><code class="language-c">char *msg = &quot;Beej was here!&quot;;
int len, bytes_sent;
.
.
len = strlen(msg);
bytes_sent = send(sockfd, msg, len, 0);
.
.
</code></pre>
<p>Remember, if the value returned by <code>send()</code> doesn‚Äôt match the value in <code>len</code>, it‚Äôs up to you to send the rest of the string. The good news is this: if the packet is small (less than 1K or so) it will probably manage to send the whole thing all in one go.</p>
<p>The <code>recv()</code> call is similar in many respects:</p>
<pre><code class="language-c">int recv(int sockfd, void *buf, int len, int flags);
</code></pre>
<p><code>recv()</code> returns the number of bytes actually read into the buffer, or -1 on error (with <code>errno</code> set, accordingly).</p>
<p>Wait! <code>recv()</code> can return <code>0</code>. This can mean only one thing: the remote side has closed the connection on you! A return value of <code>0</code> is <code>recv()</code>‚Äôs way of letting you know this has occurred.</p>
<pre><code class="language-c">int sendto(int sockfd, const void *msg, int len, unsigned int flags, const struct sockaddr *to, socklen_t tolen);
int recvfrom(int sockfd, void *buf, int len, unsigned int flags,struct sockaddr *from, int *fromlen); 
</code></pre>
<h3 id="close-and-shutdown-get-outta-my-face"><a class="header" href="#close-and-shutdown-get-outta-my-face"><code>close()</code> and <code>shutdown()</code> ‚ÄîGet outta my face!</a></h3>
<h3 id="examples"><a class="header" href="#examples">Examples!!!</a></h3>
<pre><code class="language-c">/*
** server.c -- a stream socket server demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;signal.h&gt;

#define PORT &quot;3490&quot;  // the port users will be connecting to

#define BACKLOG 10   // how many pending connections queue will hold

void sigchld_handler(int s)
{
    // waitpid() might overwrite errno, so we save and restore it:
    int saved_errno = errno;

    while(waitpid(-1, NULL, WNOHANG) &gt; 0);

    errno = saved_errno;
}


// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(void)
{
    int sockfd, new_fd;  // listen on sock_fd, new connection on new_fd
    struct addrinfo hints, *servinfo, *p;
    struct sockaddr_storage their_addr; // connector's address information
    socklen_t sin_size;
    struct sigaction sa;
    int yes=1;
    char s[INET6_ADDRSTRLEN];
    int rv;

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE; // use my IP

    if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(rv));
        return 1;
    }

    // loop through all the results and bind to the first we can
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror(&quot;server: socket&quot;);
            continue;
        }

        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes,
                sizeof(int)) == -1) {
            perror(&quot;setsockopt&quot;);
            exit(1);
        }

        if (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror(&quot;server: bind&quot;);
            continue;
        }

        break;
    }

    freeaddrinfo(servinfo); // all done with this structure

    if (p == NULL)  {
        fprintf(stderr, &quot;server: failed to bind\n&quot;);
        exit(1);
    }

    if (listen(sockfd, BACKLOG) == -1) {
        perror(&quot;listen&quot;);
        exit(1);
    }

    sa.sa_handler = sigchld_handler; // reap all dead processes
    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    if (sigaction(SIGCHLD, &amp;sa, NULL) == -1) {
        perror(&quot;sigaction&quot;);
        exit(1);
    }

    printf(&quot;server: waiting for connections...\n&quot;);

    while(1) {  // main accept() loop
        sin_size = sizeof their_addr;
        new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;sin_size);
        if (new_fd == -1) {
            perror(&quot;accept&quot;);
            continue;
        }

        inet_ntop(their_addr.ss_family,
            get_in_addr((struct sockaddr *)&amp;their_addr),
            s, sizeof s);
        printf(&quot;server: got connection from %s\n&quot;, s);

        if (!fork()) { // this is the child process
            close(sockfd); // child doesn't need the listener
            if (send(new_fd, &quot;Hello, world!&quot;, 13, 0) == -1)
                perror(&quot;send&quot;);
            close(new_fd);
            exit(0);
        }
        close(new_fd);  // parent doesn't need this
    }

    return 0;
}
</code></pre>
<pre><code class="language-c">/*
** client.c -- a stream socket client demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;arpa/inet.h&gt;

#define PORT &quot;3490&quot; // the port client will be connecting to 

#define MAXDATASIZE 100 // max number of bytes we can get at once 

// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(int argc, char *argv[])
{
    int sockfd, numbytes;  
    char buf[MAXDATASIZE];
    struct addrinfo hints, *servinfo, *p;
    int rv;
    char s[INET6_ADDRSTRLEN];

    if (argc != 2) {
        fprintf(stderr,&quot;usage: client hostname\n&quot;);
        exit(1);
    }

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    if ((rv = getaddrinfo(argv[1], PORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(rv));
        return 1;
    }

    // loop through all the results and connect to the first we can
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror(&quot;client: socket&quot;);
            continue;
        }

        if (connect(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror(&quot;client: connect&quot;);
            continue;
        }

        break;
    }

    if (p == NULL) {
        fprintf(stderr, &quot;client: failed to connect\n&quot;);
        return 2;
    }

    inet_ntop(p-&gt;ai_family, get_in_addr((struct sockaddr *)p-&gt;ai_addr),
            s, sizeof s);
    printf(&quot;client: connecting to %s\n&quot;, s);

    freeaddrinfo(servinfo); // all done with this structure

    if ((numbytes = recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
        perror(&quot;recv&quot;);
        exit(1);
    }

    buf[numbytes] = '\0';

    printf(&quot;client: received '%s'\n&quot;,buf);

    close(sockfd);

    return 0;
}
</code></pre>
<h3 id="blocking"><a class="header" href="#blocking">Blocking</a></h3>
<p>Lots of functions block. <code>accept()</code> blocks. All the <code>recv()</code> functions block. The reason they can do this is because they‚Äôre allowed to. When you first create the socket descriptor with <code>socket()</code>, the kernel sets it to blocking. If you don‚Äôt want a socket to be blocking, you have to make a call to <code>fcntl()</code>:</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
.
.
sockfd = socket(PF_INET, SOCK_STREAM, 0);
fcntl(sockfd, F_SETFL, O_NONBLOCK);
.
.
</code></pre>
<p>By setting a socket to non-blocking, you can effectively <code>‚Äúpoll‚Äù</code> the socket for information. If you try to read from a non-blocking socket and there‚Äôs no data there, it‚Äôs not allowed to block ‚Äî it will return <code>-1</code> and errno will be set to <code>EAGAIN</code> or <code>EWOULDBLOCK</code>.</p>
<p>(Wait‚Äîit can return <code>EAGAIN</code> or <code>EWOULDBLOCK</code>? Which do you check for? The specification doesn‚Äôt actually specify which your system will return, so for portability, check them both.)</p>
<p>Generally speaking, however, this type of polling is a bad idea. If you put your program in a busy-wait looking for data on the socket, you‚Äôll suck up CPU time like it was going out of style. A more elegant solution for checking to see if there‚Äôs data waiting to be read comes in the following section on <code>poll()</code>.</p>
<h3 id="poll--synchronous-io-multiplexing"><a class="header" href="#poll--synchronous-io-multiplexing"><code>poll()</code> ‚Äî Synchronous I/O Multiplexing</a></h3>
<p>What you really want to be able to do is somehow monitor a bunch of sockets at once and then handle the ones that have data ready. This way you don‚Äôt have to continously poll all those sockets to see which are ready to read.</p>
<p>So how can you avoid polling? Not slightly ironically, you can avoid polling by using the <code>poll()</code> system call. In a nutshell, we‚Äôre going to ask the operating system to do all the dirty work for us, and just let us know when some data is ready to read on which sockets. In the meantime, our process can go to sleep, saving system resources.</p>
<p>The general gameplan is to keep an array of struct <code>pollfds</code> with information about which socket descriptors we want to monitor, and what kind of events we want to monitor for. The OS will block on the <code>poll()</code> call until one of those events occurs (e.g. ‚Äúsocket ready to read!‚Äù) or until a user-specified timeout occurs.</p>
<p>Usefully, a <code>listen()</code>ing socket will return ‚Äúready to read‚Äù when a new incoming connection is ready to be <code>accept()</code>ed.</p>
<p>That‚Äôs enough banter. How do we use this?</p>
<pre><code class="language-c">#include &lt;poll.h&gt;
    
int poll(struct pollfd fds[], nfds_t nfds, int timeout);
</code></pre>
<p><code>fds</code> is our array of information (which sockets to monitor for what), <code>nfds</code> is the count of elements in the array, and <code>timeout</code> is a timeout in milliseconds. It returns the number of elements in the array that have had an event occur.</p>
<p>Let‚Äôs have a look at that struct:</p>
<pre><code class="language-c">struct pollfd {
    int fd;         // the socket descriptor
    short events;   // bitmap of events we're interested in
    short revents;  // when poll() returns, bitmap of events that occurred
};
</code></pre>
<p>So we‚Äôre going to have an array of those, and we‚Äôll see the <code>fd</code> field for each element to a socket descriptor we‚Äôre interested in monitoring. And then we‚Äôll set the events field to indicate the type of <code>events</code> we‚Äôre interested in.</p>
<p>The <code>events</code> field is the bitwise-OR of the following:</p>
<table><thead><tr><th>Macro</th><th>Description</th></tr></thead><tbody>
<tr><td><code>POLLIN</code></td><td>Alert me when data is ready to <code>recv()</code> on this socket.</td></tr>
<tr><td><code>POLLOUT</code></td><td>Alert me when I can <code>send()</code> data to this socket without blocking.</td></tr>
</tbody></table>
<p>Once you have your array of <code>struct pollfds</code> in order, then you can pass it to <code>poll()</code>, also passing the size of the array, as well as a timeout value in milliseconds. (You can specify a negative timeout to wait forever.)</p>
<p>After <code>poll()</code> returns, you can check the revents field to see if <code>POLLIN</code> or <code>POLLOUT</code> is set, indicating that event occurred.</p>
<p>(There‚Äôs actually more that you can do with the <code>poll()</code> call. See the <code>poll()</code> man page, below, for more details.)</p>
<p>Here‚Äôs an example28 where we‚Äôll wait 2.5 seconds for data to be ready to read from standard input, i.e. when you hit <code>RETURN</code>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;poll.h&gt;

int main(void)
{
    struct pollfd pfds[1]; // More if you want to monitor more

    pfds[0].fd = 0;          // Standard input
    pfds[0].events = POLLIN; // Tell me when ready to read

    // If you needed to monitor other things, as well:
    //pfds[1].fd = some_socket; // Some socket descriptor
    //pfds[1].events = POLLIN;  // Tell me when ready to read

    printf(&quot;Hit RETURN or wait 2.5 seconds for timeout\n&quot;);

    int num_events = poll(pfds, 1, 2500); // 2.5 second timeout

    if (num_events == 0) {
        printf(&quot;Poll timed out!\n&quot;);
    } else {
        int pollin_happened = pfds[0].revents &amp; POLLIN;

        if (pollin_happened) {
            printf(&quot;File descriptor %d is ready to read\n&quot;, pfds[0].fd);
        } else {
            printf(&quot;Unexpected event occurred: %d\n&quot;, pfds[0].revents);
        }
    }

    return 0;
}
</code></pre>
<p>Notice again that <code>poll()</code> returns the number of elements in the <code>pfds</code> array for which events have occurred. It doesn‚Äôt tell you which elements in the array (you still have to scan for that), but it does tell you how many entries have a non-zero <code>revents</code> field (so you can stop scanning after you find that many).</p>
<p>How can we put it all together into a chat server that you can <code>telnet</code>/<code>nc</code> to?</p>
<p>What we‚Äôll do is start a listener socket, and add it to the set of file descriptors to <code>poll()</code>. (It will show ready-to-read when there‚Äôs an incoming connection.)</p>
<p>Then we‚Äôll add new connections to our struct <code>pollfd</code> array. And we‚Äôll grow it dynamically if we run out of space.</p>
<p>When a connection is closed, we‚Äôll remove it from the array.</p>
<p>And when a connection is ready-to-read, we‚Äôll read the data from it and send that data to all the other connections so they can see what the other users typed.</p>
<p>So give this poll server a try. Run it in one window, then <code>telnet localhost 9034</code> from a number of other terminal windows. You should be able to see what you type in one window in the other ones (after you hit RETURN).</p>
<p>Not only that, but if you hit <code>CTRL-]</code> and type <code>quit</code> to exit telnet, the server should detect the disconnection and remove you from the array of file descriptors.</p>
<pre><code class="language-c">/*
** pollserver.c -- a cheezy multiperson chat server
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;poll.h&gt;

#define PORT &quot;9034&quot;   // Port we're listening on

// Get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

// Return a listening socket
int get_listener_socket(void)
{
    int listener;     // Listening socket descriptor
    int yes=1;        // For setsockopt() SO_REUSEADDR, below
    int rv;

    struct addrinfo hints, *ai, *p;

    // Get us a socket and bind it
    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;ai)) != 0) {
        fprintf(stderr, &quot;selectserver: %s\n&quot;, gai_strerror(rv));
        exit(1);
    }
    
    for(p = ai; p != NULL; p = p-&gt;ai_next) {
        listener = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);
        if (listener &lt; 0) { 
            continue;
        }
        
        // Lose the pesky &quot;address already in use&quot; error message
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));

        if (bind(listener, p-&gt;ai_addr, p-&gt;ai_addrlen) &lt; 0) {
            close(listener);
            continue;
        }

        break;
    }

    freeaddrinfo(ai); // All done with this

    // If we got here, it means we didn't get bound
    if (p == NULL) {
        return -1;
    }

    // Listen
    if (listen(listener, 10) == -1) {
        return -1;
    }

    return listener;
}

// Add a new file descriptor to the set
void add_to_pfds(struct pollfd *pfds[], int newfd, int *fd_count, int *fd_size)
{
    // If we don't have room, add more space in the pfds array
    if (*fd_count == *fd_size) {
        *fd_size *= 2; // Double it

        *pfds = realloc(*pfds, sizeof(**pfds) * (*fd_size));
    }

    (*pfds)[*fd_count].fd = newfd;
    (*pfds)[*fd_count].events = POLLIN; // Check ready-to-read

    (*fd_count)++;
}

// Remove an index from the set
void del_from_pfds(struct pollfd pfds[], int i, int *fd_count)
{
    // Copy the one from the end over this one
    pfds[i] = pfds[*fd_count-1];

    (*fd_count)--;
}

// Main
int main(void)
{
    int listener;     // Listening socket descriptor

    int newfd;        // Newly accept()ed socket descriptor
    struct sockaddr_storage remoteaddr; // Client address
    socklen_t addrlen;

    char buf[256];    // Buffer for client data

    char remoteIP[INET6_ADDRSTRLEN];

    // Start off with room for 5 connections
    // (We'll realloc as necessary)
    int fd_count = 0;
    int fd_size = 5;
    struct pollfd *pfds = malloc(sizeof *pfds * fd_size);

    // Set up and get a listening socket
    listener = get_listener_socket();

    if (listener == -1) {
        fprintf(stderr, &quot;error getting listening socket\n&quot;);
        exit(1);
    }

    // Add the listener to set
    pfds[0].fd = listener;
    pfds[0].events = POLLIN; // Report ready to read on incoming connection

    fd_count = 1; // For the listener

    // Main loop
    for(;;) {
        int poll_count = poll(pfds, fd_count, -1);

        if (poll_count == -1) {
            perror(&quot;poll&quot;);
            exit(1);
        }

        // Run through the existing connections looking for data to read
        for(int i = 0; i &lt; fd_count; i++) {

            // Check if someone's ready to read
            if (pfds[i].revents &amp; POLLIN) { // We got one!!

                if (pfds[i].fd == listener) {
                    // If listener is ready to read, handle new connection

                    addrlen = sizeof remoteaddr;
                    newfd = accept(listener,
                        (struct sockaddr *)&amp;remoteaddr,
                        &amp;addrlen);

                    if (newfd == -1) {
                        perror(&quot;accept&quot;);
                    } else {
                        add_to_pfds(&amp;pfds, newfd, &amp;fd_count, &amp;fd_size);

                        printf(&quot;pollserver: new connection from %s on &quot;
                            &quot;socket %d\n&quot;,
                            inet_ntop(remoteaddr.ss_family,
                                get_in_addr((struct sockaddr*)&amp;remoteaddr),
                                remoteIP, INET6_ADDRSTRLEN),
                            newfd);
                    }
                } else {
                    // If not the listener, we're just a regular client
                    int nbytes = recv(pfds[i].fd, buf, sizeof buf, 0);

                    int sender_fd = pfds[i].fd;

                    if (nbytes &lt;= 0) {
                        // Got error or connection closed by client
                        if (nbytes == 0) {
                            // Connection closed
                            printf(&quot;pollserver: socket %d hung up\n&quot;, sender_fd);
                        } else {
                            perror(&quot;recv&quot;);
                        }

                        close(pfds[i].fd); // Bye!

                        del_from_pfds(pfds, i, &amp;fd_count);

                    } else {
                        // We got some good data from a client

                        for(int j = 0; j &lt; fd_count; j++) {
                            // Send to everyone!
                            int dest_fd = pfds[j].fd;

                            // Except the listener and ourselves
                            if (dest_fd != listener &amp;&amp; dest_fd != sender_fd) {
                                if (send(dest_fd, buf, nbytes, 0) == -1) {
                                    perror(&quot;send&quot;);
                                }
                            }
                        }
                    }
                } // END handle data from client
            } // END got ready-to-read from poll()
        } // END looping through file descriptors
    } // END for(;;)--and you thought it would never end!
    
    return 0;
}
</code></pre>
<p>An interesting task to is to swich <code>poll</code> above to <code>epoll</code> on Linux or <code>kqueue</code> on Mac.</p>
<p>For now, a similar server implement in Rust could be like:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use std::io::{Read, Write};
use std::net::{Shutdown, SocketAddr, TcpListener, TcpStream};
use std::sync::mpsc::{channel, Receiver, Sender};
use std::sync::{Arc, Mutex};
use std::thread;

fn handle_client(
    mut stream: TcpStream,
    sender_agent: Sender&lt;(SocketAddr, String)&gt;, // agent sender for broadcast message to others
    receiver: Receiver&lt;String&gt;, // broadcast receiver to get message from other client
    peer_addr: SocketAddr,      // client addr
    sender_map: Arc&lt;Mutex&lt;HashMap&lt;SocketAddr, Sender&lt;String&gt;&gt;&gt;&gt;, // handle for remove disconnected senders from sender_map
) {
    let mut data = [0 as u8; 50]; // using 50 byte buffer

    let mut stream_clone = stream.try_clone().expect(&quot;clone failed...&quot;);
    std::thread::spawn(move || {
        while match receiver.recv() {
            Ok(msg) =&gt; {
                stream_clone.write(msg.as_bytes()).unwrap();
                true
            }
            Err(e) =&gt; {
                println!(&quot;Client {} disconnected. Message: {}&quot;, peer_addr, e);
                false
            }
        } {}
    });

    while match stream.read(&amp;mut data) {
        Ok(0) =&gt; {
            // Stream ended as client closed, clean up stuff here
            sender_map.lock().unwrap().remove(&amp;peer_addr);
            false
        }
        Ok(size) =&gt; {
            // echo everything!
            // stream.write(&amp;data[0..size]).unwrap();
            let to_send = std::str::from_utf8(&amp;data[0..size]).unwrap_or(&quot;?&quot;).into();
            match sender_agent.send((peer_addr.clone(), to_send)) {
                Ok(_) =&gt; true,
                Err(e) =&gt; {
                    println!(&quot;{}&quot;, e);
                    sender_map.lock().unwrap().remove(&amp;peer_addr);
                    false
                }
            }
        }
        Err(_) =&gt; {
            println!(
                &quot;An error occurred, terminating connection with {}&quot;,
                stream.peer_addr().unwrap()
            );
            stream.shutdown(Shutdown::Both).unwrap();
            false
        }
    } {}
}

fn main() {
    let listener = TcpListener::bind(&quot;0.0.0.0:3333&quot;).unwrap();
    // accept connections and process them, spawning a new thread for each one
    println!(&quot;Server listening on port 3333&quot;);

    let (sender_agent, recv_agent) = channel::&lt;(SocketAddr, String)&gt;();
    let sender_map: Arc&lt;Mutex&lt;HashMap&lt;SocketAddr, Sender&lt;String&gt;&gt;&gt;&gt; =
        Arc::new(Mutex::new(HashMap::new()));
    let sender_map_copy = sender_map.clone();

    // Agent thread
    thread::spawn(move || {
        while match recv_agent.recv() {
            Ok((addr, msg)) =&gt; {
                print!(&quot;[{}]: {}&quot;, &amp;addr, msg.as_str());
                for (key, sender_in_map) in sender_map_copy.lock().unwrap().iter() {
                    if key == &amp;addr {
                        continue;
                    }

                    match sender_in_map.send(format!(&quot;[{}]: {}&quot;, addr, msg)) {
                        Ok(_) =&gt; {}
                        Err(e) =&gt; println!(&quot;{}&quot;, e),
                    }
                }
                true
            }
            Err(e) =&gt; {
                println!(&quot;{:?}&quot;, e);
                true
            }
        } {}
    });

    for stream in listener.incoming() {
        let sender_agent_copy = sender_agent.clone();
        let (sender_in_map, recv) = channel();
        match stream {
            Ok(mut stream) =&gt; {
                let peer_addr = stream.peer_addr().unwrap();
                println!(&quot;New connection: {}&quot;, peer_addr);
                stream
                    .write(format!(&quot;Welcome {}\n&quot;, peer_addr).as_bytes())
                    .unwrap();

                let sender_map_copy = sender_map.clone();
                sender_map_copy
                    .lock()
                    .unwrap()
                    .insert(peer_addr.clone(), sender_in_map.clone());
                thread::spawn(move || {
                    // connection succeeded
                    handle_client(stream, sender_agent_copy, recv, peer_addr, sender_map_copy)
                });
            }
            Err(e) =&gt; {
                println!(&quot;Error: {}&quot;, e);
                /* connection failed */
            }
        }
    }
    // close the socket server
    drop(listener);
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../rust_note/resources.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../tech/java/java.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../rust_note/resources.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../tech/java/java.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../mermaid.min.js"></script>
        
        <script type="text/javascript" src="../mermaid-init.js"></script>
        

        

    </body>
</html>
