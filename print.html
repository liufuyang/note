<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Personal notebook</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="note.html"><strong aria-hidden="true">1.</strong> Note</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="note_1/1.html"><strong aria-hidden="true">1.1.</strong> Note 1</a></li></ol></li><li class="chapter-item expanded "><a href="algorithms.html"><strong aria-hidden="true">2.</strong> Algorithms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="algorithms/1.html"><strong aria-hidden="true">2.1.</strong> Big O notations</a></li><li class="chapter-item expanded "><a href="algorithms/stack_queue.html"><strong aria-hidden="true">2.2.</strong> Stack and Queue</a></li><li class="chapter-item expanded "><a href="algorithms/devide_conquer.html"><strong aria-hidden="true">2.3.</strong> Divide and Conquer</a></li><li class="chapter-item expanded "><a href="algorithms/sort.html"><strong aria-hidden="true">2.4.</strong> Sort</a></li><li class="chapter-item expanded "><a href="algorithms/dynamic_programming.html"><strong aria-hidden="true">2.5.</strong> Dynamic programming</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Rust note</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> General</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust_note/general/cpp_memory_model.html"><strong aria-hidden="true">3.1.1.</strong> C++ memory mode</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Note from courses</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust_note/courses/pattern_matching.html"><strong aria-hidden="true">3.2.1.</strong> Pattern matching</a></li><li class="chapter-item expanded "><a href="rust_note/courses/smart_pointers.html"><strong aria-hidden="true">3.2.2.</strong> Smart pointers</a></li><li class="chapter-item expanded "><a href="rust_note/courses/string.html"><strong aria-hidden="true">3.2.3.</strong> String</a></li></ol></li><li class="chapter-item expanded "><a href="rust_note/tokio.html"><strong aria-hidden="true">3.3.</strong> Note for tokio dev</a></li><li class="chapter-item expanded "><a href="rust_note/resources.html"><strong aria-hidden="true">3.4.</strong> Resources</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Tech notes</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="tech/network_programming.html"><strong aria-hidden="true">4.1.</strong> Network Programming</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Good Tips</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="sub/topic_1.html"><strong aria-hidden="true">5.1.</strong> Some Markdown Tips</a></li><li class="chapter-item expanded "><a href="sub/life_tips.html"><strong aria-hidden="true">5.2.</strong> Life Tips</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Personal notebook</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/liufuyang/note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="notebook"><a class="header" href="#notebook">Notebook</a></h1>
<p>This is a personal notebook. <a href="https://github.com/liufuyang/note">See repo here</a>.
Let's see how often I can keep this updated...</p>
<h2 id="how-to-update-my-note"><a class="header" href="#how-to-update-my-note">How to update my note:</a></h2>
<p><a href="https://rust-lang.github.io/mdBook">https://rust-lang.github.io/mdBook</a></p>
<p>And take a look at <a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">Markdown Help</a> for some hints.</p>
<ul>
<li><code>mdbook serve --dest-dir docs --open</code></li>
<li>Edit content</li>
<li>Then perhaps build again <code>mdbook build --dest-dir docs</code></li>
<li>Then push </li>
</ul>
<details>
<summary>Some hidden code here</summary>
<pre><pre class="playground"><code class="language-rust">use warp::Filter;

#[tokio::main]
async fn main() {
    let routes = warp::any().map(|| &quot;Hello, World!&quot;);
    warp::serve(routes).run(([127, 0, 0, 1], 3030)).await;
}
</code></pre></pre>
</details>
<h2 id="how-to-add-some-graphs"><a class="header" href="#how-to-add-some-graphs">How to add some graphs?</a></h2>
<p>https://github.com/badboy/mdbook-mermaid</p>
<p>And see the <code>Dockerfile</code> in the repo how to make an image that can build the site.</p>
<h2 id="about-github-page-build"><a class="header" href="#about-github-page-build">About github page build</a></h2>
<p>This github action <a href="https://github.com/peaceiris/actions-gh-pages">peaceiris/actions-gh-pages</a> seems really handy.
<a href="https://github.com/liufuyang/note/actions/workflows/gh-pages.yml">See the config file here</a></p>
<h1 id="note-1"><a class="header" href="#note-1">Note 1</a></h1>
<h2 id="some-random-notes-that-could-be-useful"><a class="header" href="#some-random-notes-that-could-be-useful">Some random notes that could be useful:</a></h2>
<p>How to make http slides:</p>
<p><a href="https://liufuyang.github.io/http-kv/demo.html">https://liufuyang.github.io/http-kv/demo.html</a></p>
<h1 id="algorithms"><a class="header" href="#algorithms">Algorithms</a></h1>
<p><img src="./algorithms/order_of_growth.png" alt="" /></p>
<h1 id="big-o-notations"><a class="header" href="#big-o-notations">Big O notations</a></h1>
<p>Commonly-used notations in the theory of algorithms</p>
<table><thead><tr><th>notation</th><th>example</th><th>provides</th><th align="center">shorthand for</th><th>used to</th></tr></thead><tbody>
<tr><td><strong>Big Theta</strong></td><td>\( \Theta (N^2) \)</td><td>asymptotic order of growth</td><td align="center">\( {1 \over 2} \ N^2 \) <br /> \( 10 \ N^2 \) <br /> \( 5 N^2 + 2 N \log N + 3 N \)</td><td>classify algorithms</td></tr>
<tr><td><strong>Big Oh</strong></td><td>\( O (N^2) \)</td><td>\(\Theta(N^2) \) and smaller</td><td align="center">\( 10 \ N^2 \) <br /> \( 100 \ N \) <br /> \( 2 N \log N + 3 N \)</td><td>develop upper bounds</td></tr>
<tr><td><strong>Big Omega</strong></td><td>\( \Omega (N^2) \)</td><td>\( \Theta(N^2) \) and larger</td><td align="center">\( {1 \over 2} \ N^2 \) <br /> \( N^5 \) <br /> \( N^3 + 2 N \log N + 3 N \)</td><td>develop lower bounds</td></tr>
<tr><td><strong>Tilde</strong> *</td><td>\( \sim 10 \ N^2 \)</td><td>leading term</td><td align="center">\( 10 \ N^2 \) <br /> \( 10 \ N^2 + 22 N \log N \) <br /> \( 10 \ N^2 + 2 N + 37 \)</td><td>provide approximate model</td></tr>
</tbody></table>
<p>* A common mistake is interpreting <code>Big-Oh</code> as an approximate model <code>Tilde</code>.</p>
<h2 id=""><a class="header" href="#"></a></h2>
<p><img src="algorithms/order_of_growth.png" alt="" /></p>
<h1 id="stack-and-queue"><a class="header" href="#stack-and-queue">Stack and Queue</a></h1>
<h2 id="two-major-implementations"><a class="header" href="#two-major-implementations">Two major implementations</a></h2>
<ul>
<li>Linked list impl</li>
<li>Array impl</li>
</ul>
<p>which can both implement stack and queue.</p>
<h2 id="linked-list-impl"><a class="header" href="#linked-list-impl">Linked list impl</a></h2>
<p>For stack or queue, a single direction link list will do,
so only need a <code>head</code> point to the head node, and a <code>tail</code> point to the tail node.</p>
<pre><code>(head) -&gt; (a,) -&gt; (b,) -&gt; (c,)
(tail) - - - - - - - - - - ^
</code></pre>
<p>A simple unsafe Rust implementation could use structures like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Node&lt;T&gt; {
    element: T,
    next: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,
}

pub struct LinkedList&lt;T&gt; {
    head: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,
    tail: *mut Node&lt;T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>More code can be see here on <a href="https://github.com/liufuyang/algs4/tree/main/algs_stanford/src">my own bad Rust stack/queue implementation</a></p>
<ul>
<li><code>push</code> add node via <code>head</code>;</li>
<li><code>enqueue</code> add node via <code>tail</code>;</li>
<li><code>pop</code> or <code>dequeue</code>, just take out nodes from <code>head</code>.</li>
</ul>
<p>Or in short <code>adding on both ends, removing from head only</code>.</p>
<h2 id="array-impl"><a class="header" href="#array-impl">Array impl</a></h2>
<pre><code>  0   1   2   3   4   5   6   7
[__, __,  a,  b,  c, __, __, __,]
(head) ---^
(tail) - - - - - - - ^
</code></pre>
<ul>
<li><code>push</code> or <code>enqueue</code>, just add via <code>tail</code>;</li>
<li><code>pop</code> removes nodes from <code>tail</code>;</li>
<li><code>dequeue</code> removes from <code>head</code>;</li>
</ul>
<p>Or in short <code>adding from tail only, removing from both ends</code>.</p>
<p>Other trivial details:</p>
<ul>
<li>When reaching the end while adding, increase capacity by factor of 2;</li>
<li>When <code>tail</code> less than 1/4 of capacity, can reduce capacity by 1/2 of current capacity, to save space;</li>
<li>In Java, when removing element from the list, besides change
head and tail values, also set <code>null</code> to the array so to let
those removed nodes can be garbage collected later. </li>
</ul>
<h2 id="dequeue---a-double-ended-queue"><a class="header" href="#dequeue---a-double-ended-queue">Dequeue - a double-ended queue</a></h2>
<p>Dequeue -a double-ended queue or <code>deque</code> (pronounced “deck”)
is a generalization of a stack and a queue that supports adding and removing items from either the front or the back of the data structure.</p>
<p>One type of implementation could be using a <code>double linked list</code>, so both ends can remove nodes.</p>
<p>Another approach (I suppose) could be using <code>two stacks</code>, with either stack implementations mentioned above.
Then one stack is kept as <code>positive</code> while another kept as 
<code>negative</code>.</p>
<p>So the <code>deque</code> can probably be implemented as something like:</p>
<pre><code class="language-java">    // add the item to the front
    public void addFirst(Item item) {
        negative.push();
    }

    // add the item to the back
    public void addLast(Item item) {
        positive.push();
    }

    // remove and return the item from the front
    public Optional&lt;Item&gt; removeFirst() {
        if (!negative.isEmpty) {
            return negative.pop();
        } else {
            return positive.dequeue();
        }
    }

    // remove and return the item from the back
    public Optional&lt;Item&gt; removeLast() {
        if (!positive.isEmpty) {
            return positive.pop();
        } else {
            return negative.dequeue();
        }
    }
</code></pre>
<p>Haven't tried to do my homework with the Princeton course,
but hopefully this works. Otherwise the code might later 
be at <a href="https://github.com/liufuyang/algs4/tree/main/algs_princeton/2_queues">here</a>.
Update: As the homework requires <code>constant worst time</code> so 
I used a double linked list to implement it. So I can
just guess now the above idea will work :)</p>
<h2 id="randomizedqueue"><a class="header" href="#randomizedqueue">RandomizedQueue</a></h2>
<p>A <code>RandomizedQueue</code> can be implemented with a normal
array implementation queue, plus using <strong><code>Knuth Shuffle</code></strong>
during <code>enqueue</code> operation:</p>
<pre><code class="language-java">public void enqueue(Item item) {
    if (item == null) {
      throw new IllegalArgumentException();
    }
    if (items.length == tail) {
      resize(Math.max(items.length, size() * 2));
    }
    items[tail] = item;
    tail++;

    swap(tail - 1, StdRandom.uniform(head, tail));
  }
</code></pre>
<p>Key is on that <code>swap</code> call. Basically the shuffle
idea is very simple, when adding a new item into
the array, then randomly select an item from the 
array (including the newly added one) then swap
the newly added one with the selected item.</p>
<p>See <a href="https://github.com/liufuyang/algs4/tree/main/algs_princeton/2_queues">code here</a>.</p>
<p>By the way, this <strong><code>Knuth Shuffle</code></strong> idea seems
pretty powerful as it uses linear time for shuffling
a N-th array. Better than make N random floats and 
sort them to have a new index list.</p>
<h2 id="linked-list-impl-vs-array-impl"><a class="header" href="#linked-list-impl-vs-array-impl">Linked list impl vs Array impl</a></h2>
<p>I guess simply put, </p>
<ul>
<li><code>linked list</code> is good for constant time
operations <strong>in the worst case</strong>, though slower each time, 
an uses more space;</li>
<li><code>resizing array</code> is 
in most cases very fast, occasionally slow when resizing,
with the claim of adding an element has constant <strong>amortized time</strong> cost. And less wasted space</li>
</ul>
<hr />
<h2 id="use-stackqueue-for-search-algorithm"><a class="header" href="#use-stackqueue-for-search-algorithm">Use stack/queue for Search Algorithm</a></h2>
<p>One quite useful thing about <code>stack</code> and <code>queue</code> is that</p>
<ul>
<li><code>stack</code> can be used for <code>Depth-First Search</code> (DFS)</li>
<li><code>queue</code> can be used for <code>Breadth-First Search</code> (BFS)</li>
</ul>
<iframe width="640" height="360" src="https://www.youtube.com/embed/WbzNRTTrX0g?t=1557" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Quite interesting.</p>
<p>It seems that a general &quot;Graph Search&quot; type of problem 
can be solved by this abstract framework:</p>
<blockquote>
<ul>
<li><code>agent</code> - entity that perceives its environment and acts upon that environment</li>
<li><code>state</code> - a configuration of the agent and
its environment;
<code>initial state</code> - the state in which the agent begins </li>
<li><code>actions</code> - choices that can be made in a state, like edges in graphs; <code>ACTIONS(s)</code> returns the set of actions that
can be executed in state s</li>
<li><code>transition model</code> or <code>RESULT(s, a)</code>
returns the state resulting from performing action a in state s</li>
<li><code>goal test</code> - way to determine whether a given state
is a goal state</li>
<li><code>path cost</code> - numerical cost associated with a given path</li>
<li><code>frontier</code> - a stack or queue to keep track of the nodes to be explored</li>
</ul>
</blockquote>
<p>Then with a <code>node</code> defined as 
<strong>a data structure that keeps track of</strong></p>
<ul>
<li>a <code>state</code></li>
<li>a <code>parent</code> (node that generated this node)</li>
<li>an <code>action</code> (action applied to parent to get node)</li>
<li>a <code>path cost</code> (from initial state to node)</li>
</ul>
<p>Then a search algorithm can be defined as:</p>
<h3 id="search-algorithm"><a class="header" href="#search-algorithm"><strong>Search algorithm</strong></a></h3>
<ul>
<li>Start with a <code>frontier</code> that contains the initial state.</li>
<li>Start with an empty explored set.</li>
<li>Repeat:
<ul>
<li>If the <code>frontier</code> is empty, then no solution.</li>
<li>Remove a <code>node</code> from the <code>frontier</code>. (Also using a set to keep track of visited <code>nodes</code>)</li>
<li>If <code>node</code> contains goal state (<code>goal test</code>), return the solution.</li>
<li>Add the <code>node</code> to the explored set.</li>
<li>Expand <code>node</code> (<code>ACTIONS + RESULTS</code>), add resulting <code>nodes</code> to the <code>frontier</code> if they
aren't already in the <code>frontier</code> or the explored set.</li>
</ul>
</li>
</ul>
<p>For example, in a simple maze search problem, the <code>state</code> of 
the node is just the current position, the <code>actions</code> of the 
node is just the next possible directions that the agent can go to, leading to the following states.</p>
<p>In a social network problem, for example in the homework's
movie actors <code>degree</code> problem, the <code>state</code> of 
the node is just the actor id, the <code>actions</code> of the 
node is just the movies this actor performed, which can lead to other <code>state</code> (or actors).</p>
<p>Some example code on the <code>degree</code> problem might look like this.</p>
<pre><code class="language-python">def shortest_path(source, target):
    &quot;&quot;&quot;
    Returns the shortest list of (movie_id, person_id) pairs that connect the source to the target.
    
    If no possible path, returns None.

    Action: movie id
    State: person id
    &quot;&quot;&quot;

    start = Node(state=source, parent=None, action=None)
    frontier = QueueFrontier()
    frontier.add(start)
    explored = set()

    while True:
        if frontier.empty():
            return None
        
        node = frontier.remove()
        explored.add(node.state)

        for action in people[node.state][&quot;movies&quot;]:
            for state in movies[action][&quot;stars&quot;]: 
                if not frontier.contains_state(state) and state not in explored:
                    child = Node(state=state, parent=node, action=action)
                    frontier.add(child)

                    checkNode = child
                    if checkNode.state == target:
                        actions_and_states = []
                        while checkNode.parent is not None:
                            actions_and_states.append((checkNode.action, checkNode.state))
                            checkNode = checkNode.parent
                        actions_and_states.reverse()
                        return actions_and_states
</code></pre>
<p>And normally a <code>queue</code> is used as the <code>frontier</code> in order 
to perform <code>Breadth-First Search</code> - which seem to be the 
best option for general problems as you want to find the shortest path to the goal.</p>
<p>One variant of the algorithms is a <strong>greedy best-first search</strong></p>
<ul>
<li><code>A* search</code>: search algorithm that expands node with
lowest value of <code>g(n) + h(n)</code>
<ul>
<li><code>g(n)</code> = cost to reach node</li>
<li><code>h(n)</code> = estimated cost to goal</li>
<li>optimal if
<ul>
<li><code>h(n)</code> is admissible (never overestimates the
true cost), and</li>
<li><code>h(n)</code> is consistent (for every node n and
successor n' with step cost c, <code>h(n) ≤ h(n') + c)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Another variant of this type of algorithm is <code>Adversarial Search</code> - which is used for problems like Tic-Tac-Toe games</p>
<p>So for games:</p>
<ul>
<li>S0 : initial state</li>
<li>PLAYER(s) : returns which player to move in state s</li>
<li>ACTIONS(s) : returns legal moves in state s</li>
<li>RESULT(s, a) : returns state after action a taken in state s</li>
<li>TERMINAL(s) : checks if state s is a terminal state</li>
<li>UTILITY(s) : final numerical value for terminal state s</li>
</ul>
<p>One method is called <strong><code>MinMax</code></strong></p>
<ul>
<li>Given a state s:</li>
<li>MAX picks action a in ACTIONS(s) that produces
highest value of MIN-VALUE(RESULT(s, a))</li>
<li>MIN picks action a in ACTIONS(s) that produces
smallest value of MAX-VALUE(RESULT(s, a))</li>
</ul>
<p>Or in code as:</p>
<pre><code>function MAX-VALUE(state):
 if TERMINAL(state):
 return UTILITY(state)
 v = -∞
 for action in ACTIONS(state):
 v = MAX(v, MIN-VALUE(RESULT(state, action)))
 return v

function MIN-VALUE(state):
 if TERMINAL(state):
 return UTILITY(state)
 v = ∞
 for action in ACTIONS(state):
 v = MIN(v, MAX-VALUE(RESULT(state, action)))
 return v
</code></pre>
<p>And some special pruning method such as Alpha-Beta Pruning is
needed for game problems with very large search space.</p>
<h1 id="divide-and-conquer"><a class="header" href="#divide-and-conquer">Divide and Conquer</a></h1>
<ol>
<li>Divide into smaller problems</li>
<li>Conquer via recursive calls</li>
<li>Combine solutions of sub-problems into one for the 
original problem.</li>
</ol>
<h2 id="typical-problems"><a class="header" href="#typical-problems">Typical problems:</a></h2>
<ul>
<li>
<p>Merge sort (recursive or bottom up)</p>
</li>
<li>
<p>Karatsuba Multiplication</p>
</li>
<li>
<p>Counting Inversions</p>
<p>Example: (1, 3, 5, 2, 4, 6), having inversions: (3,2), (5,2), (5, 4)</p>
<p>Can be used for: calculate the similarity between 2 persons' 10 movies sort order.</p>
</li>
</ul>
<h2 id="counting-inversions"><a class="header" href="#counting-inversions">Counting Inversions</a></h2>
<p>Naive implementation is \( O(n^2) \) as we need 2 for loops.
Via divide and conquer, what we need is this</p>
<pre><code>Count(array a, length n) {
    if n == 1 return 0
    else 
      x = Count(left half of a, n/2)
      y = Count(right half of a, n/2)
      z = CountSplitInv(a, n)

      return x + y + z
}
</code></pre>
<p><code>CountSplitInv</code> counting the split inversions, where first
index is in the first half array, and second index is in the 
second half array.
Then the question is, can we do <code>CountSplitInv</code> with 
\( O(n) \)? If so, the divide part has \( O(\log n) \), which gives us the final algorithms speed of \( O(n \log n) \). Intuitively feels not possible.</p>
<h3 id="piggybacking-on-merge-sort"><a class="header" href="#piggybacking-on-merge-sort">Piggybacking on Merge Sort</a></h3>
<pre><code>SortAndCount(array a, length n) {
    if n == 1 return 0
    else 
      b, x = SortAndCount(left half of a, n/2)
      c, y = SortAndCount(right half of a, n/2)
      d, z = MergeAndCountSplitInv(b, c, n)

      return d, x + y + z
}
</code></pre>
<p>After sorting, we can do the trick, or &quot;piggybacking&quot; 
while merge:</p>
<pre><code>i=0
j=0
z=0
for k = 0 .. n-1 {
    if b[i] &lt;= c[j] {
        d[k] = b[i]
        i++
    } else {
        d[k] = c[j]
        j++
        z += b.len - i // piggybacking part of merge
    }
}
</code></pre>
<p>So if <code>b</code>'s element all less than <code>c</code>'s element, 
before <code>j</code> starts to add, <code>i</code> will be as <code>b.len</code>, making <code>z=0</code> in the end.</p>
<p>Or the general claim:</p>
<blockquote>
<p>Claim: the numberr of split inversions involving an element 
<code>c_j</code> from 2nd array <code>c</code> is precisely the number of elements
left in the 1st array <code>b</code> when <code>c_j</code> is copied to the output <code>d</code>.</p>
</blockquote>
<p>So basically we ended with a very similar thing to Merge Sort,
only one more operation on the merge operations. So we
achieved \( O(n \log n) \). Pretty impressive.</p>
<h2 id="the-master-method"><a class="header" href="#the-master-method">The Master Method</a></h2>
<p>\[ 
\begin{align}
\text{If }  \quad  T(n) &amp; &lt;= a T (\frac{n}{b}) + O(n^d) \\ 
\text{Then } \quad  T(n) &amp; =
\begin{cases}
O(n^d \log n)       &amp; \quad \text{if } a = b^d \text{ (Case 1)} \\
O(n^d)              &amp; \quad \text{if } a &lt; b^d \text{ (Case 2)} \\
O(n^{\log_{b}{a} }) &amp; \quad \text{if } a &gt; b^d \text{ (Case 3)}
\end{cases}
\end{align}
\]</p>
<p>For example</p>
<ul>
<li>merge sort having <code>a=2, b=2, d=1</code> so it is \( O(n \log n)  \), which is case 1</li>
<li>binary search having <code>a=1, b=2, d=0</code> so it is \( O(\log n)  \), which is case 1</li>
<li>Karatsuba Multiplication <code>a=3, b=2, d=1</code> so it is \( O(n^{\log_2 3}) = O(n^{1.59}) \), which is case 3</li>
</ul>
<p>A simple proof could be: At each level \( j=0,1,2,..,log_b(n) \), there are \(a^j\) subproblems, each of size \( n \over b^j \).
Then the total number of operations needed to solve the whole
problem for each level is:
\[
a^j  C {\left[\frac{n}{b^j}\right]}^d = C n^d {\left[\frac{a}{b^d}\right]}^j
\]
Thus the total number of the whole problem is:
\[
\text{total work} \leq \displaystyle\sum_{j=0}^{\log_b n} C n^d {\left[\frac{a}{b^d}\right]}^j
\]
where</p>
<ul>
<li>\( a \): rate of subproblem proliferation (<code>RSP</code>)</li>
<li>\( b^d \): rate of work shrinkage per subproblem (<code>RWS</code>)</li>
</ul>
<p>And we see:</p>
<ul>
<li>If <code>RSP &lt; RWS</code>, then the amount of work is decreasing with the recursion level <code>j</code></li>
<li>If <code>RSP &gt; RWS</code>, then the amount of work is increasing with the recursion level <code>j</code></li>
<li>If <code>RSP = RWS</code>, then the amount of work is the same at every recursion level <code>j</code></li>
</ul>
<h1 id="sort"><a class="header" href="#sort">Sort</a></h1>
<ul>
<li><strong>Merge sort</strong>
<ul>
<li>\( n \log(n) \) in worst case</li>
<li>a <code>stable</code> sort (sort by column A, then sort by column B, then for the same B, order of A preserves)</li>
<li>simple to understand, divide and conquer (or bottom up to avoid recursion); <code>log(n)</code> levels, and each level's merge takes <code>n</code> operation, thus \( n \log(n) \)  will do</li>
</ul>
</li>
<li><strong>Quick sort</strong>
<ul>
<li>
<p>\( n \log(n) \) in worst case</p>
</li>
<li>
<p>not a <code>stable</code> sort</p>
</li>
<li>
<p>more tricky but not difficult to understand, divide and conquer: <br></p>
<p>make sure an element's left are all smaller (or equal to) it, and the
right part are all bigger than it (let's called it <code>partitioned</code>); then continue to sort both on left and right part;</p>
</li>
<li>
<p>to make an array <code>partitioned</code> by, for eg. the first element: <br></p>
<pre><code>[3, 5, 2, 6, 1, 4]
i---^
j---^
</code></pre>
<p>Start with <code>i</code> and <code>j</code> both after first element.
<code>i</code> stands for <code>left of me is smaller than pivot</code>; <code>j</code> stands for <code>left of me is partitioned</code>. <br></p>
<p>So basically we loop each element until <code>j</code> is <code>n</code>;<br></p>
<p>For each step:<br></p>
<ul>
<li>If <code>a[j] &gt;= pivot</code>, then just <code>j++</code>;</li>
<li>If <code>a[j] &lt; pivot</code>, then <code>swap(i, j)</code>, <code>i++, j++</code>;</li>
<li>When <code>j</code> reaches the end, <code>swap(i-i, 0)</code>, return <code>i-1</code></li>
</ul>
<pre><code>[3, 5, 2, 6, 1, 4]
i---^
j------^
</code></pre>
<p>swap</p>
<pre><code>[3, 2, 5, 6, 1, 4]
i------^
j---------^
</code></pre>
<pre><code>[3, 2, 5, 6, 1, 4]
i------^
j------------^
</code></pre>
<p>swap</p>
<pre><code>[3, 2, 1, 6, 5, 4]
i---------^
j------------^
</code></pre>
<pre><code>[3, 2, 1, 6, 5, 4]
i---------^
j-----------------^
</code></pre>
<p>then last swap and return <code>i=2</code></p>
<pre><code>[1, 2, 3, 6, 5, 4]
i---------^
j-----------------^
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="dynamic-programming"><a class="header" href="#dynamic-programming">Dynamic programming</a></h1>
<h2 id="fibonacci"><a class="header" href="#fibonacci">Fibonacci</a></h2>
<h3 id="recursion---exponential-waste"><a class="header" href="#recursion---exponential-waste">Recursion - Exponential waste</a></h3>
<p>A novice programmer might implement a recersion like this below. But it has a problem called <code>expoential waste</code>.</p>
<pre><code class="language-java">public class FibonacciR
{
  public static long F(int n)
  {
    if (n == 0) return 0;
    if (n == 1) return 1;
    return F(n-1) + F(n-2);
  }
  public static void main(String[] args)
  {
    int n = Integer.parseInt(args[0]);
    StdOut.println(F(n));
  }
}
</code></pre>
<p>The issue of the recursion above is that there are many duplicated calculations performed.
So the core of the algorithms of opertimization is to reduced the number of operations.
And since we have many calculation already done so there should be a way to save the 
results, then later calculations can use the previous calculatined values.</p>
<p>This could be the core idea of <code>Dynamic programming</code>.</p>
<h3 id="avoiding-exponential-waste"><a class="header" href="#avoiding-exponential-waste">Avoiding exponential waste</a></h3>
<p>Memoization</p>
<ul>
<li>Maintain an array <code>memo[]</code> to
remember all computed values.</li>
<li>If value known, just return it.</li>
<li>Otherwise, compute it, remember
it, and then return it.</li>
</ul>
<pre><code class="language-java">public class FibonacciM
{
 static long[] memo = new long[100];
 public static long F(int n)
 {
  if (n == 0) return 0;
  if (n == 1) return 1;
  if (memo[n] == 0)
    memo[n] = F(n-1) + F(n-2);
  return memo[n];
 }
 public static void main(String[] args)
 {
  int n = Integer.parseInt(args[0]);
  StdOut.println(F(n));
 }
}
</code></pre>
<h2 id="dynamic-programming-1"><a class="header" href="#dynamic-programming-1">Dynamic programming</a></h2>
<p>Dynamic programming.</p>
<ul>
<li>Build computation from the <strong>&quot;bottom up&quot;</strong>.</li>
<li>Solve small subproblems and save solutions.</li>
<li>Use those solutions to build bigger solutions.</li>
</ul>
<pre><code class="language-java">public class Fibonacci
{
  public static void main(String[] args)
  {
    int n = Integer.parseInt(args[0]);
    long[] F = new long[n+1];
    F[0] = 0; F[1] = 1;
    for (int i = 2; i &lt;= n; i++)
      F[i] = F[i-1] + F[i-2];
    StdOut.println(F[n]);
  }
}
</code></pre>
<h3 id="dp-example-longest-common-subsequence-lcs"><a class="header" href="#dp-example-longest-common-subsequence-lcs">DP example: Longest common subsequence (LCS)</a></h3>
<p><img src="https://user-images.githubusercontent.com/161689/112751290-78a3cb00-8fcd-11eb-9225-5c8f086e3cd0.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/161689/112751326-a5f07900-8fcd-11eb-8cc9-f93de888ab5f.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/161689/112751344-bdc7fd00-8fcd-11eb-95b8-e5cf29b7f606.png" alt="image" /></p>
<h3 id="lcs-length-implementation"><a class="header" href="#lcs-length-implementation">LCS length implementation</a></h3>
<pre><code class="language-java">public class LCS
{
  public static void main(String[] args)
  {
    String s = args[0];
    String t = args[1];
    int M = s.length();
    int N = t.length();
    int[][] opt = new int[M+1][N+1];
    for (int i = M-1; i &gt;= 0; i--)
      for (int j = N-1; j &gt;= 0; j--)
        if (s.charAt(i) == t.charAt(j))
          opt[i][j] = opt[i+1][j+1] + 1;
        else
          opt[i][j] = Math.max(opt[i+1][j], opt[i][j+1]);
    System.out.println(opt[0][0]);
 }
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/161689/112755860-e0184580-8fe2-11eb-9291-37f63af490d9.png" alt="image" /></p>
<p>More notes will come when the alg course touches on dynamic programming later. The above content are from the Princeton's 
course <em>Computer Science: Programming with a Purpose</em>.</p>
<h1 id="c-memory-mode"><a class="header" href="#c-memory-mode">C++ memory mode</a></h1>
<ul>
<li>[[Video Link]](https://www.youtube.com/watch?v=OyNG4qiWnmU)</li>
<li>[[Some docs about it]](https://doc.rust-lang.org/nomicon/atomics.html)</li>
</ul>
<h1 id="memory-order"><a class="header" href="#memory-order">Memory order</a></h1>
<ul>
<li>Acquire / Release</li>
<li>Sequentially Consistent (SeqCst)</li>
<li>Relaxed</li>
</ul>
<h2 id="acquire-release"><a class="header" href="#acquire-release">Acquire-Release</a></h2>
<p>Sort of like mutex primitives, aquire=lock, release=unlock. Acquire and Release are largely intended to be paired.</p>
<ul>
<li>
<p><code>release</code> update the memory, &quot;publish&quot; to other threads, used only with <code>store</code> type operation(save/publish data out, cannot use with load)</p>
</li>
<li>
<p><code>acquire</code> memory &quot;published&quot; by other threads, making it available to us, used only with <code>load</code> type of operation (cannot use with store)</p>
</li>
<li>
<p>For &quot;load and store&quot; type of operation:</p>
<ul>
<li><code>release</code> will make load <code>relaxed</code> and store <code>release</code></li>
<li><code>acquire</code> will make load <code>acquire</code> and store <code>relaxed</code></li>
</ul>
</li>
<li>
<p><code>AcqRel</code> or acquire and release also exist, so can be used for &quot;load and store&quot; type of operation, 
making load <code>acquire</code> and store <code>release</code> (no relaxed). 
This operation order could be handy for situation such as for an Arc type of thing in the end to drop
the internal object, it may use some operation like <code>load_and_minors_1_then_store</code> so you would 
use this <code>AcqRel</code> to make sure the thread got the updated value and all other threads has updated value when they read.
This is illustrated in the video.</p>
</li>
</ul>
<p>Intuitively, an acquire access ensures that every access after it stays after it. However operations that occur before an acquire are free to be reordered to occur after it. Similarly, a release access ensures that every access before it stays before it. However operations that occur after a release are free to be reordered to occur before it.</p>
<p>When thread A releases a location in memory and then thread B subsequently acquires the same location in memory, causality is established. <strong>Every write (including non-atomic and relaxed atomic writes) that happened before A's release will be observed by B after its acquisition.</strong> However no causality is established with any other threads. Similarly, no causality is established if A and B access different locations in memory.</p>
<p>Or using the words from the video:</p>
<ul>
<li>acquire/release: no total order of events</li>
<li>each thread has it view of consistent ordering</li>
</ul>
<p>Basic use of release-acquire is therefore simple: you acquire a location of memory to begin the critical section, and then release that location to end it. For instance, a simple spinlock might look like:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};
use std::thread;

fn main() {
    let lock = Arc::new(AtomicBool::new(false)); // value answers &quot;am I locked?&quot;

    // ... distribute lock to threads somehow ...

    // Try to acquire the lock by setting it to true
    while lock.compare_and_swap(false, true, Ordering::Acquire) {
        // c++ code here could be: std::this_threadd::yield() to let other thread run
     }
    // broke out of the loop, so we successfully acquired the lock!

    // ... scary data accesses, but safe to do stuff here ...

    // ok we're done, release the lock
    lock.store(false, Ordering::Release);
}
</code></pre></pre>
<h2 id="sequentially-consistent"><a class="header" href="#sequentially-consistent">Sequentially Consistent</a></h2>
<p>Be cause there is no total order of events for acquire/release, Sequentially Consistent is 
introduced.</p>
<p>Sequentially Consistent is the most powerful of all, implying the restrictions of all other orderings. Intuitively, a sequentially consistent operation cannot be reordered: all accesses on one thread that happen before and after a SeqCst access stay before and after it. A data-race-free program that uses only sequentially consistent atomics and data accesses has the very nice property that there is a single global execution of the program's instructions that all threads agree on. This execution is also particularly nice to reason about: it's just an interleaving of each thread's individual executions. This does not hold if you start using the weaker atomic orderings.</p>
<p>The relative developer-friendliness of sequential consistency doesn't come for free. Even on strongly-ordered platforms sequential consistency involves emitting memory fences.</p>
<p>In practice, sequential consistency is rarely necessary for program correctness. However sequential consistency is definitely the right choice if you're not confident about the other memory orders. Having your program run a bit slower than it needs to is certainly better than it running incorrectly! It's also mechanically trivial to downgrade atomic operations to have a weaker consistency later on. Just change <code>SeqCst</code> to <code>Relaxed</code> and you're done! Of course, proving that this transformation is correct is a whole other matter.</p>
<h2 id="relaxed"><a class="header" href="#relaxed">Relaxed</a></h2>
<p>Relaxed accesses are the absolute weakest. They can be freely re-ordered and provide no happens-before relationship. Still, relaxed operations are still atomic. That is, they don't count as data accesses and any read-modify-write operations done to them occur atomically. Relaxed operations are appropriate for things that you definitely want to happen, but don't particularly otherwise care about. For instance, incrementing a counter can be safely done by multiple threads using a relaxed <code>fetch_add</code> if you're not using the counter to synchronize any other accesses.</p>
<p>There's rarely a benefit in making an operation relaxed on strongly-ordered platforms, since they usually provide release-acquire semantics anyway. However relaxed operations can be cheaper on weakly-ordered platforms.</p>
<h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern matching</a></h1>
<p>Patterns come in two forms: refutable and irrefutable. 
Patterns that will match for any possible value passed are <em>irrefutable</em>. An example would be x in the statement <code>let x = 5;</code> because <code>x</code> matches anything and therefore cannot fail to match. 
(Meaning it always will have a match.)</p>
<p>Patterns that can fail to match for some possible value are <em>refutable</em>. An example would be <code>Some(x)</code> in the expression <code>if let Some(x) = a_value</code> because if the value in the <code>a_value</code> variable is <code>None</code> rather than <code>Some</code>, the <code>Some(x)</code> pattern will not match.</p>
<h2 id="pattern-matching-type"><a class="header" href="#pattern-matching-type">Pattern matching type</a></h2>
<ul>
<li><code>let</code> - only irrefutable</li>
<li>fn param, closure - only irrefutable</li>
<li><code>match</code> exp - accept refutable and irrefutable</li>
<li><code>if let</code> exp - accept refutable and irrefutable</li>
<li><code>while let</code> exp - accept refutable and irrefutable</li>
<li><code>for</code> exp - only irrefutable</li>
</ul>
<h2 id="let"><a class="header" href="#let">let</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {x: isize, y: isize};
let (a, b) = (1, 2);
let Point {x, y} = Point {x:3, y:4};
assert_eq!(3, x);
assert_eq!(4, y);
<span class="boring">}
</span></code></pre></pre>
<h2 id="no-need-to-write-ref"><a class="header" href="#no-need-to-write-ref">No need to write <code>ref</code>?</a></h2>
<p>Compiler helps you adding <code>ref</code> when matching references with
non-references like expressions.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Option&lt;String&gt; = Some(&quot;hello&quot;.into());
match &amp;x {
    Some(s) =&gt; println!(&quot;{}&quot;, s), // nothing moves here, `s` is a &amp;String,
                                  // the same as `Some(ref s) =&gt; ...`, with `ref` added by compiler behind the scene
    None =&gt; println!(&quot;nothing&quot;)
}
println!(&quot;{}&quot;, x.unwrap());       // x still owns the String 
<span class="boring">}
</span></code></pre></pre>
<h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart pointers</a></h1>
<p>Smart pointers allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data.</p>
<ul>
<li><code>Box&lt;T&gt;</code> for allocating values on the heap</li>
<li><code>Rc&lt;T&gt;</code>, a reference counting type that enables multiple ownership</li>
<li><code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code>, accessed through <code>RefCell&lt;T&gt;</code>, a type that enforces the borrowing rules at runtime instead of compile time</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s_on_stack: Box&lt;&amp;str&gt; = Box::new(&quot;hello&quot;); // string is still on stack
let s_on_heap: Box&lt;str&gt; = Box::from(&quot;hello&quot;); // string is copied onto heap
println!(&quot;s_on_stack = {}&quot;, s_on_stack);
println!(&quot;s_on_heap = {}&quot;, s_on_heap);
<span class="boring">}
</span></code></pre></pre>
<h2 id="using-deref-trait-to-auto-dereference"><a class="header" href="#using-deref-trait-to-auto-dereference">Using <code>Deref</code> trait to auto dereference</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

struct MySmartPointer&lt;T&gt;{hold: T}

impl&lt;T&gt; MySmartPointer&lt;T&gt; {
    fn new(hold: T) -&gt; MySmartPointer&lt;T&gt; {
        MySmartPointer{hold}
    }
}

impl&lt;T&gt; Deref for MySmartPointer&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.hold
    }
}

// using it
struct User {
    name: &amp;'static str
}

impl User {
    fn print_name(&amp;self) {
        println!(&quot;My name is {}&quot;, self.name);
    }
}

fn main() {
    let user_pointer = MySmartPointer::new(User {name: &quot;Alex&quot;});
    user_pointer.print_name(); // auto deref
}
</code></pre></pre>
<h2 id="using-box-for-unknown-size-type"><a class="header" href="#using-box-for-unknown-size-type">Using <code>Box</code> for unknown size type</a></h2>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(i32, List),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
    println!(&quot;{:?}&quot;, list);
    // recursive type has infinite size, won't compile
}
</code></pre></pre>
<p>Above code won't compile as Rust cannot know the size of a <code>List</code> as it is recursive. Now we can use <code>Box&lt;&gt;</code> to make it's size known at compile time.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
    println!(&quot;{:?}&quot;, list);
}
</code></pre></pre>
<h1 id="string"><a class="header" href="#string">String</a></h1>
<h2 id="char"><a class="header" href="#char">char</a></h2>
<p>Actually a <code>4-byte fixed size</code> or <code>u32</code> type of value.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tao: char = '道';
println!(&quot;'道' as u32: {}&quot;, tao as u32); // 36947 char is basically u32 size unicode
println!(&quot;U+{:x}&quot;, tao as u32);  // U+9053 - output in 0x or hexadecimal(16) format
println!(&quot;{}&quot;, tao.escape_unicode()); // \u{9053}
println!(&quot;{}&quot;, char::from(65)); // from a u8 -&gt; 'A'
println!(&quot;{}&quot;, std::char::from_u32(0x9053).unwrap()); // from a u32
println!(&quot;{}&quot;, std::char::from_u32(36947).unwrap()); // from a u32
println!(&quot;{}&quot;, std::char::from_u32(1234567).unwrap_or('_')); // not every u32 is a char

// noticing a char uses 4-byte in memory but not all the space is always used
assert_eq!(3, tao.len_utf8()); // effective data length in byte
assert_eq!(4, std::mem::size_of_val(&amp;tao));
<span class="boring">}
</span></code></pre></pre>
<h2 id="string-1"><a class="header" href="#string-1">String</a></h2>
<p><code>String</code> is basically a <code>Vec&lt;u8&gt;</code>.</p>
<p>Other type:</p>
<ul>
<li><code>Cstr/Cstring</code></li>
<li><code>OsStr/OsString</code></li>
<li><code>Path/PathBuf</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tao = std::str::from_utf8(&amp;[0xe9u8, 0x81u8, 0x93u8]).unwrap();
println!(&quot;{}&quot;, tao);

let tao = String::from(&quot;\u{9053}&quot;);
println!(&quot;{}&quot;, tao);
<span class="boring">}
</span></code></pre></pre>
<h3 id="a-char-like-string-might-not-be-a-char"><a class="header" href="#a-char-like-string-might-not-be-a-char">A char like String might not be a char</a></h3>
<p>A single &quot;char&quot; looking thing - like ❤️ - doesn't means it is a valid char. Some of those single looking characters needs more than 
one <code>char</code> or <code>code points</code> to be represented:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(6, String::from(&quot;❤️&quot;).len()); // length in byte
assert_eq!(6, std::mem::size_of_val(String::from(&quot;❤️&quot;).as_str())); // same calculation as above
assert_eq!(2, String::from(&quot;❤️&quot;).chars().count()); // how many `code points` - is 2?
// as ❤️ takes 2 code points , we can't assign it to a char
// let heart = '❤️'; // This won't work

assert_eq!(1, String::from(&quot;道&quot;).chars().count()); // 道 can be defined as a char as it only has 1 code point
assert_eq!('道', String::from(&quot;道&quot;).chars().next().unwrap());
assert_eq!(3, String::from(&quot;道&quot;).len());
assert_eq!(3, std::mem::size_of_val(String::from(&quot;道&quot;).as_str()));
<span class="boring">}
</span></code></pre></pre>
<h3 id="é-is-not-e"><a class="header" href="#é-is-not-e">'é' is not 'é'</a></h3>
<p>As always, remember that a human intuition for 'character' may not map to Unicode's definitions. For example, despite looking similar, the 'é' character is one Unicode code point while 'é' is two Unicode code points:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(1, String::from(&quot;é&quot;).chars().count()); // '\u{00e9}' -&gt; latin small letter e with acute
assert_eq!(2, String::from(&quot;é&quot;).chars().count()); // '\u{0065}' + '\u{0301}' -&gt; U+0065: 'latin small letter e', U+0301: 'combining acute accent'
// They look the same in editor but have different code points ?!
<span class="boring">}
</span></code></pre></pre>
<h1 id="note-for-tokio-dev"><a class="header" href="#note-for-tokio-dev">Note for tokio dev</a></h1>
<p>Frequently used command:</p>
<pre><code># Run a single integration test
cargo test --test tcp_into_std

# Run a single doc test
cargo test --doc net::tcp::stream::TcpStream::into_std

# Format code
rustfmt --edition 2018 $(find . -name '*.rs' -print)
</code></pre>
<h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<h2 id="good-posts-and-links"><a class="header" href="#good-posts-and-links">Good posts and links</a></h2>
<ul>
<li><a href="https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html">Rust: A unique perspective - Matt Brubeck</a></li>
<li><a href="https://manishearth.github.io/blog/2018/01/10/whats-tokio-and-async-io-all-about/">What Are Tokio and Async IO All About? - Manish Goregaokar</a></li>
<li><a href="https://ryhl.io/blog/async-what-is-blocking/">Async: What is blocking? - Alice Ryhl</a></li>
</ul>
<h1 id="network-programming"><a class="header" href="#network-programming">Network Programming</a></h1>
<p>http://beej.us/guide/bgnet/html/</p>
<h2 id="two-types-of-internet-sockets"><a class="header" href="#two-types-of-internet-sockets">Two Types of Internet Sockets</a></h2>
<ul>
<li><code>SOCK_STREAM</code> -&gt; TCP</li>
<li><code>SOCK_DGRAM</code>-&gt; UDP, may lost, may out of order, but fast</li>
</ul>
<h4 id="layered-network-model-data-encapsulation"><a class="header" href="#layered-network-model-data-encapsulation">Layered Network Model (Data Encapsulation)</a></h4>
<ul>
<li>Application Layer (telnet, ftp, etc.)</li>
<li>Host-to-Host Transport Layer (TCP, UDP) - port number (16-bit number)</li>
<li>Internet Layer (IP and routing)</li>
<li>Network Access Layer (Ethernet, wi-fi, or whatever)</li>
</ul>
<p>See how much work there is in building a simple packet? All you have to do for stream sockets is <code>send()</code> the data out.
All you have to do for <code>datagram sockets</code> is encapsulate the packet in the method of your choosing and <code>sendto()</code> it out. The kernel builds the Transport Layer and Internet Layer on for you and the hardware does the Network Access Layer. Ah, modern technology.</p>
<h3 id="system-calls"><a class="header" href="#system-calls">System calls</a></h3>
<h4 id="bind---what-port-am-i-on"><a class="header" href="#bind---what-port-am-i-on"><code>bind()</code> - What port am I on?</a></h4>
<pre><code class="language-c">struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():
memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

getaddrinfo(NULL, &quot;3490&quot;, &amp;hints, &amp;res);

// make a socket:
sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// bind it to the port we passed in to getaddrinfo():
bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
</code></pre>
<h4 id="connect---hey-you"><a class="header" href="#connect---hey-you"><code>connect()</code> - Hey, you!</a></h4>
<pre><code class="language-c">struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;

getaddrinfo(&quot;www.example.com&quot;, &quot;3490&quot;, &amp;hints, &amp;res);

// make a socket:
sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// connect!
connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
</code></pre>
<p>Also, notice that we didn’t call <code>bind()</code>. Basically, we don’t care about our local port number; we only care where we’re going (the remote port). <strong>The kernel will choose a local port for us</strong>, and the site we connect to will automatically get this information from us. No worries.</p>
<h4 id="listen---keep-on-answering-stuff"><a class="header" href="#listen---keep-on-answering-stuff"><code>listen()</code> - Keep on answering stuff</a></h4>
<pre><code class="language-c">int listen(int sockfd, int backlog);
</code></pre>
<p><code>sockfd</code> is the usual socket file descriptor from the <code>socket()</code> system call. <code>backlog</code> is the number of connections allowed on the incoming queue. What does that mean? Well, incoming connections are going to wait in this queue until you <code>accept()</code> them and this is the limit on how many can queue up. Most systems silently limit this number to about 20; you can probably get away with setting it to 5 or 10.</p>
<p>Well, as you can probably imagine, we need to call <code>bind()</code> before we call <code>listen()</code> so that the server is running on a specific port.</p>
<h4 id="accept---thank-you-for-calling-port-3490"><a class="header" href="#accept---thank-you-for-calling-port-3490"><code>accept()</code> - &quot;Thank you for calling port 3490.&quot;</a></h4>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 
</code></pre>
<p>You call <code>accept()</code> and you tell it to get the pending connection. It’ll return to you a brand new socket file descriptor to use for this single connection! That’s right, suddenly you have two socket file descriptors for the price of one! The original one is still listening for more new connections, and the newly created one is finally ready to <code>send()</code> and <code>recv()</code></p>
<h4 id="send-and-recv---talk-to-me-baby"><a class="header" href="#send-and-recv---talk-to-me-baby"><code>send()</code> and <code>recv()</code> - Talk to me, baby!</a></h4>
<p>For UDP - <code>sendto()</code> and <code>recvfrom()</code>.</p>
<pre><code class="language-c">int send(int sockfd, const void *msg, int len, int flags); 
</code></pre>
<p>Example:</p>
<pre><code class="language-c">char *msg = &quot;Beej was here!&quot;;
int len, bytes_sent;
.
.
len = strlen(msg);
bytes_sent = send(sockfd, msg, len, 0);
.
.
</code></pre>
<p>Remember, if the value returned by <code>send()</code> doesn’t match the value in <code>len</code>, it’s up to you to send the rest of the string. The good news is this: if the packet is small (less than 1K or so) it will probably manage to send the whole thing all in one go.</p>
<p>The <code>recv()</code> call is similar in many respects:</p>
<pre><code class="language-c">int recv(int sockfd, void *buf, int len, int flags);
</code></pre>
<p><code>recv()</code> returns the number of bytes actually read into the buffer, or -1 on error (with <code>errno</code> set, accordingly).</p>
<p>Wait! <code>recv()</code> can return <code>0</code>. This can mean only one thing: the remote side has closed the connection on you! A return value of <code>0</code> is <code>recv()</code>’s way of letting you know this has occurred.</p>
<pre><code class="language-c">int sendto(int sockfd, const void *msg, int len, unsigned int flags, const struct sockaddr *to, socklen_t tolen);
int recvfrom(int sockfd, void *buf, int len, unsigned int flags,struct sockaddr *from, int *fromlen); 
</code></pre>
<h3 id="close-and-shutdown-get-outta-my-face"><a class="header" href="#close-and-shutdown-get-outta-my-face"><code>close()</code> and <code>shutdown()</code> —Get outta my face!</a></h3>
<h3 id="examples"><a class="header" href="#examples">Examples!!!</a></h3>
<pre><code class="language-c">/*
** server.c -- a stream socket server demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;signal.h&gt;

#define PORT &quot;3490&quot;  // the port users will be connecting to

#define BACKLOG 10   // how many pending connections queue will hold

void sigchld_handler(int s)
{
    // waitpid() might overwrite errno, so we save and restore it:
    int saved_errno = errno;

    while(waitpid(-1, NULL, WNOHANG) &gt; 0);

    errno = saved_errno;
}


// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(void)
{
    int sockfd, new_fd;  // listen on sock_fd, new connection on new_fd
    struct addrinfo hints, *servinfo, *p;
    struct sockaddr_storage their_addr; // connector's address information
    socklen_t sin_size;
    struct sigaction sa;
    int yes=1;
    char s[INET6_ADDRSTRLEN];
    int rv;

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE; // use my IP

    if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(rv));
        return 1;
    }

    // loop through all the results and bind to the first we can
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror(&quot;server: socket&quot;);
            continue;
        }

        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes,
                sizeof(int)) == -1) {
            perror(&quot;setsockopt&quot;);
            exit(1);
        }

        if (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror(&quot;server: bind&quot;);
            continue;
        }

        break;
    }

    freeaddrinfo(servinfo); // all done with this structure

    if (p == NULL)  {
        fprintf(stderr, &quot;server: failed to bind\n&quot;);
        exit(1);
    }

    if (listen(sockfd, BACKLOG) == -1) {
        perror(&quot;listen&quot;);
        exit(1);
    }

    sa.sa_handler = sigchld_handler; // reap all dead processes
    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    if (sigaction(SIGCHLD, &amp;sa, NULL) == -1) {
        perror(&quot;sigaction&quot;);
        exit(1);
    }

    printf(&quot;server: waiting for connections...\n&quot;);

    while(1) {  // main accept() loop
        sin_size = sizeof their_addr;
        new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;sin_size);
        if (new_fd == -1) {
            perror(&quot;accept&quot;);
            continue;
        }

        inet_ntop(their_addr.ss_family,
            get_in_addr((struct sockaddr *)&amp;their_addr),
            s, sizeof s);
        printf(&quot;server: got connection from %s\n&quot;, s);

        if (!fork()) { // this is the child process
            close(sockfd); // child doesn't need the listener
            if (send(new_fd, &quot;Hello, world!&quot;, 13, 0) == -1)
                perror(&quot;send&quot;);
            close(new_fd);
            exit(0);
        }
        close(new_fd);  // parent doesn't need this
    }

    return 0;
}
</code></pre>
<pre><code class="language-c">/*
** client.c -- a stream socket client demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;arpa/inet.h&gt;

#define PORT &quot;3490&quot; // the port client will be connecting to 

#define MAXDATASIZE 100 // max number of bytes we can get at once 

// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(int argc, char *argv[])
{
    int sockfd, numbytes;  
    char buf[MAXDATASIZE];
    struct addrinfo hints, *servinfo, *p;
    int rv;
    char s[INET6_ADDRSTRLEN];

    if (argc != 2) {
        fprintf(stderr,&quot;usage: client hostname\n&quot;);
        exit(1);
    }

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    if ((rv = getaddrinfo(argv[1], PORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(rv));
        return 1;
    }

    // loop through all the results and connect to the first we can
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror(&quot;client: socket&quot;);
            continue;
        }

        if (connect(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror(&quot;client: connect&quot;);
            continue;
        }

        break;
    }

    if (p == NULL) {
        fprintf(stderr, &quot;client: failed to connect\n&quot;);
        return 2;
    }

    inet_ntop(p-&gt;ai_family, get_in_addr((struct sockaddr *)p-&gt;ai_addr),
            s, sizeof s);
    printf(&quot;client: connecting to %s\n&quot;, s);

    freeaddrinfo(servinfo); // all done with this structure

    if ((numbytes = recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
        perror(&quot;recv&quot;);
        exit(1);
    }

    buf[numbytes] = '\0';

    printf(&quot;client: received '%s'\n&quot;,buf);

    close(sockfd);

    return 0;
}
</code></pre>
<h3 id="blocking"><a class="header" href="#blocking">Blocking</a></h3>
<p>Lots of functions block. <code>accept()</code> blocks. All the <code>recv()</code> functions block. The reason they can do this is because they’re allowed to. When you first create the socket descriptor with <code>socket()</code>, the kernel sets it to blocking. If you don’t want a socket to be blocking, you have to make a call to <code>fcntl()</code>:</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
.
.
sockfd = socket(PF_INET, SOCK_STREAM, 0);
fcntl(sockfd, F_SETFL, O_NONBLOCK);
.
.
</code></pre>
<p>By setting a socket to non-blocking, you can effectively <code>“poll”</code> the socket for information. If you try to read from a non-blocking socket and there’s no data there, it’s not allowed to block — it will return <code>-1</code> and errno will be set to <code>EAGAIN</code> or <code>EWOULDBLOCK</code>.</p>
<p>(Wait—it can return <code>EAGAIN</code> or <code>EWOULDBLOCK</code>? Which do you check for? The specification doesn’t actually specify which your system will return, so for portability, check them both.)</p>
<p>Generally speaking, however, this type of polling is a bad idea. If you put your program in a busy-wait looking for data on the socket, you’ll suck up CPU time like it was going out of style. A more elegant solution for checking to see if there’s data waiting to be read comes in the following section on <code>poll()</code>.</p>
<h3 id="poll--synchronous-io-multiplexing"><a class="header" href="#poll--synchronous-io-multiplexing"><code>poll()</code> — Synchronous I/O Multiplexing</a></h3>
<p>What you really want to be able to do is somehow monitor a bunch of sockets at once and then handle the ones that have data ready. This way you don’t have to continously poll all those sockets to see which are ready to read.</p>
<p>So how can you avoid polling? Not slightly ironically, you can avoid polling by using the <code>poll()</code> system call. In a nutshell, we’re going to ask the operating system to do all the dirty work for us, and just let us know when some data is ready to read on which sockets. In the meantime, our process can go to sleep, saving system resources.</p>
<p>The general gameplan is to keep an array of struct <code>pollfds</code> with information about which socket descriptors we want to monitor, and what kind of events we want to monitor for. The OS will block on the <code>poll()</code> call until one of those events occurs (e.g. “socket ready to read!”) or until a user-specified timeout occurs.</p>
<p>Usefully, a <code>listen()</code>ing socket will return “ready to read” when a new incoming connection is ready to be <code>accept()</code>ed.</p>
<p>That’s enough banter. How do we use this?</p>
<pre><code class="language-c">#include &lt;poll.h&gt;
    
int poll(struct pollfd fds[], nfds_t nfds, int timeout);
</code></pre>
<p><code>fds</code> is our array of information (which sockets to monitor for what), <code>nfds</code> is the count of elements in the array, and <code>timeout</code> is a timeout in milliseconds. It returns the number of elements in the array that have had an event occur.</p>
<p>Let’s have a look at that struct:</p>
<pre><code class="language-c">struct pollfd {
    int fd;         // the socket descriptor
    short events;   // bitmap of events we're interested in
    short revents;  // when poll() returns, bitmap of events that occurred
};
</code></pre>
<p>So we’re going to have an array of those, and we’ll see the <code>fd</code> field for each element to a socket descriptor we’re interested in monitoring. And then we’ll set the events field to indicate the type of <code>events</code> we’re interested in.</p>
<p>The <code>events</code> field is the bitwise-OR of the following:</p>
<table><thead><tr><th>Macro</th><th>Description</th></tr></thead><tbody>
<tr><td><code>POLLIN</code></td><td>Alert me when data is ready to <code>recv()</code> on this socket.</td></tr>
<tr><td><code>POLLOUT</code></td><td>Alert me when I can <code>send()</code> data to this socket without blocking.</td></tr>
</tbody></table>
<p>Once you have your array of <code>struct pollfds</code> in order, then you can pass it to <code>poll()</code>, also passing the size of the array, as well as a timeout value in milliseconds. (You can specify a negative timeout to wait forever.)</p>
<p>After <code>poll()</code> returns, you can check the revents field to see if <code>POLLIN</code> or <code>POLLOUT</code> is set, indicating that event occurred.</p>
<p>(There’s actually more that you can do with the <code>poll()</code> call. See the <code>poll()</code> man page, below, for more details.)</p>
<p>Here’s an example28 where we’ll wait 2.5 seconds for data to be ready to read from standard input, i.e. when you hit <code>RETURN</code>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;poll.h&gt;

int main(void)
{
    struct pollfd pfds[1]; // More if you want to monitor more

    pfds[0].fd = 0;          // Standard input
    pfds[0].events = POLLIN; // Tell me when ready to read

    // If you needed to monitor other things, as well:
    //pfds[1].fd = some_socket; // Some socket descriptor
    //pfds[1].events = POLLIN;  // Tell me when ready to read

    printf(&quot;Hit RETURN or wait 2.5 seconds for timeout\n&quot;);

    int num_events = poll(pfds, 1, 2500); // 2.5 second timeout

    if (num_events == 0) {
        printf(&quot;Poll timed out!\n&quot;);
    } else {
        int pollin_happened = pfds[0].revents &amp; POLLIN;

        if (pollin_happened) {
            printf(&quot;File descriptor %d is ready to read\n&quot;, pfds[0].fd);
        } else {
            printf(&quot;Unexpected event occurred: %d\n&quot;, pfds[0].revents);
        }
    }

    return 0;
}
</code></pre>
<p>Notice again that <code>poll()</code> returns the number of elements in the <code>pfds</code> array for which events have occurred. It doesn’t tell you which elements in the array (you still have to scan for that), but it does tell you how many entries have a non-zero <code>revents</code> field (so you can stop scanning after you find that many).</p>
<p>How can we put it all together into a chat server that you can <code>telnet</code>/<code>nc</code> to?</p>
<p>What we’ll do is start a listener socket, and add it to the set of file descriptors to <code>poll()</code>. (It will show ready-to-read when there’s an incoming connection.)</p>
<p>Then we’ll add new connections to our struct <code>pollfd</code> array. And we’ll grow it dynamically if we run out of space.</p>
<p>When a connection is closed, we’ll remove it from the array.</p>
<p>And when a connection is ready-to-read, we’ll read the data from it and send that data to all the other connections so they can see what the other users typed.</p>
<p>So give this poll server a try. Run it in one window, then <code>telnet localhost 9034</code> from a number of other terminal windows. You should be able to see what you type in one window in the other ones (after you hit RETURN).</p>
<p>Not only that, but if you hit <code>CTRL-]</code> and type <code>quit</code> to exit telnet, the server should detect the disconnection and remove you from the array of file descriptors.</p>
<pre><code class="language-c">/*
** pollserver.c -- a cheezy multiperson chat server
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;poll.h&gt;

#define PORT &quot;9034&quot;   // Port we're listening on

// Get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

// Return a listening socket
int get_listener_socket(void)
{
    int listener;     // Listening socket descriptor
    int yes=1;        // For setsockopt() SO_REUSEADDR, below
    int rv;

    struct addrinfo hints, *ai, *p;

    // Get us a socket and bind it
    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;ai)) != 0) {
        fprintf(stderr, &quot;selectserver: %s\n&quot;, gai_strerror(rv));
        exit(1);
    }
    
    for(p = ai; p != NULL; p = p-&gt;ai_next) {
        listener = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);
        if (listener &lt; 0) { 
            continue;
        }
        
        // Lose the pesky &quot;address already in use&quot; error message
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));

        if (bind(listener, p-&gt;ai_addr, p-&gt;ai_addrlen) &lt; 0) {
            close(listener);
            continue;
        }

        break;
    }

    freeaddrinfo(ai); // All done with this

    // If we got here, it means we didn't get bound
    if (p == NULL) {
        return -1;
    }

    // Listen
    if (listen(listener, 10) == -1) {
        return -1;
    }

    return listener;
}

// Add a new file descriptor to the set
void add_to_pfds(struct pollfd *pfds[], int newfd, int *fd_count, int *fd_size)
{
    // If we don't have room, add more space in the pfds array
    if (*fd_count == *fd_size) {
        *fd_size *= 2; // Double it

        *pfds = realloc(*pfds, sizeof(**pfds) * (*fd_size));
    }

    (*pfds)[*fd_count].fd = newfd;
    (*pfds)[*fd_count].events = POLLIN; // Check ready-to-read

    (*fd_count)++;
}

// Remove an index from the set
void del_from_pfds(struct pollfd pfds[], int i, int *fd_count)
{
    // Copy the one from the end over this one
    pfds[i] = pfds[*fd_count-1];

    (*fd_count)--;
}

// Main
int main(void)
{
    int listener;     // Listening socket descriptor

    int newfd;        // Newly accept()ed socket descriptor
    struct sockaddr_storage remoteaddr; // Client address
    socklen_t addrlen;

    char buf[256];    // Buffer for client data

    char remoteIP[INET6_ADDRSTRLEN];

    // Start off with room for 5 connections
    // (We'll realloc as necessary)
    int fd_count = 0;
    int fd_size = 5;
    struct pollfd *pfds = malloc(sizeof *pfds * fd_size);

    // Set up and get a listening socket
    listener = get_listener_socket();

    if (listener == -1) {
        fprintf(stderr, &quot;error getting listening socket\n&quot;);
        exit(1);
    }

    // Add the listener to set
    pfds[0].fd = listener;
    pfds[0].events = POLLIN; // Report ready to read on incoming connection

    fd_count = 1; // For the listener

    // Main loop
    for(;;) {
        int poll_count = poll(pfds, fd_count, -1);

        if (poll_count == -1) {
            perror(&quot;poll&quot;);
            exit(1);
        }

        // Run through the existing connections looking for data to read
        for(int i = 0; i &lt; fd_count; i++) {

            // Check if someone's ready to read
            if (pfds[i].revents &amp; POLLIN) { // We got one!!

                if (pfds[i].fd == listener) {
                    // If listener is ready to read, handle new connection

                    addrlen = sizeof remoteaddr;
                    newfd = accept(listener,
                        (struct sockaddr *)&amp;remoteaddr,
                        &amp;addrlen);

                    if (newfd == -1) {
                        perror(&quot;accept&quot;);
                    } else {
                        add_to_pfds(&amp;pfds, newfd, &amp;fd_count, &amp;fd_size);

                        printf(&quot;pollserver: new connection from %s on &quot;
                            &quot;socket %d\n&quot;,
                            inet_ntop(remoteaddr.ss_family,
                                get_in_addr((struct sockaddr*)&amp;remoteaddr),
                                remoteIP, INET6_ADDRSTRLEN),
                            newfd);
                    }
                } else {
                    // If not the listener, we're just a regular client
                    int nbytes = recv(pfds[i].fd, buf, sizeof buf, 0);

                    int sender_fd = pfds[i].fd;

                    if (nbytes &lt;= 0) {
                        // Got error or connection closed by client
                        if (nbytes == 0) {
                            // Connection closed
                            printf(&quot;pollserver: socket %d hung up\n&quot;, sender_fd);
                        } else {
                            perror(&quot;recv&quot;);
                        }

                        close(pfds[i].fd); // Bye!

                        del_from_pfds(pfds, i, &amp;fd_count);

                    } else {
                        // We got some good data from a client

                        for(int j = 0; j &lt; fd_count; j++) {
                            // Send to everyone!
                            int dest_fd = pfds[j].fd;

                            // Except the listener and ourselves
                            if (dest_fd != listener &amp;&amp; dest_fd != sender_fd) {
                                if (send(dest_fd, buf, nbytes, 0) == -1) {
                                    perror(&quot;send&quot;);
                                }
                            }
                        }
                    }
                } // END handle data from client
            } // END got ready-to-read from poll()
        } // END looping through file descriptors
    } // END for(;;)--and you thought it would never end!
    
    return 0;
}
</code></pre>
<p>An interesting task to is to swich <code>poll</code> above to <code>epoll</code> on Linux or <code>kqueue</code> on Mac.</p>
<p>For now, a similar server implement in Rust could be like:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use std::io::{Read, Write};
use std::net::{Shutdown, SocketAddr, TcpListener, TcpStream};
use std::sync::mpsc::{channel, Receiver, Sender};
use std::sync::{Arc, Mutex};
use std::thread;

fn handle_client(
    mut stream: TcpStream,
    sender_agent: Sender&lt;(SocketAddr, String)&gt;, // agent sender for broadcast message to others
    receiver: Receiver&lt;String&gt;, // broadcast receiver to get message from other client
    peer_addr: SocketAddr,      // client addr
    sender_map: Arc&lt;Mutex&lt;HashMap&lt;SocketAddr, Sender&lt;String&gt;&gt;&gt;&gt;, // handle for remove disconnected senders from sender_map
) {
    let mut data = [0 as u8; 50]; // using 50 byte buffer

    let mut stream_clone = stream.try_clone().expect(&quot;clone failed...&quot;);
    std::thread::spawn(move || {
        while match receiver.recv() {
            Ok(msg) =&gt; {
                stream_clone.write(msg.as_bytes()).unwrap();
                true
            }
            Err(e) =&gt; {
                println!(&quot;Client {} disconnected. Message: {}&quot;, peer_addr, e);
                false
            }
        } {}
    });

    while match stream.read(&amp;mut data) {
        Ok(0) =&gt; {
            // Stream ended as client closed, clean up stuff here
            sender_map.lock().unwrap().remove(&amp;peer_addr);
            false
        }
        Ok(size) =&gt; {
            // echo everything!
            // stream.write(&amp;data[0..size]).unwrap();
            let to_send = std::str::from_utf8(&amp;data[0..size]).unwrap_or(&quot;?&quot;).into();
            match sender_agent.send((peer_addr.clone(), to_send)) {
                Ok(_) =&gt; true,
                Err(e) =&gt; {
                    println!(&quot;{}&quot;, e);
                    sender_map.lock().unwrap().remove(&amp;peer_addr);
                    false
                }
            }
        }
        Err(_) =&gt; {
            println!(
                &quot;An error occurred, terminating connection with {}&quot;,
                stream.peer_addr().unwrap()
            );
            stream.shutdown(Shutdown::Both).unwrap();
            false
        }
    } {}
}

fn main() {
    let listener = TcpListener::bind(&quot;0.0.0.0:3333&quot;).unwrap();
    // accept connections and process them, spawning a new thread for each one
    println!(&quot;Server listening on port 3333&quot;);

    let (sender_agent, recv_agent) = channel::&lt;(SocketAddr, String)&gt;();
    let sender_map: Arc&lt;Mutex&lt;HashMap&lt;SocketAddr, Sender&lt;String&gt;&gt;&gt;&gt; =
        Arc::new(Mutex::new(HashMap::new()));
    let sender_map_copy = sender_map.clone();

    // Agent thread
    thread::spawn(move || {
        while match recv_agent.recv() {
            Ok((addr, msg)) =&gt; {
                print!(&quot;[{}]: {}&quot;, &amp;addr, msg.as_str());
                for (key, sender_in_map) in sender_map_copy.lock().unwrap().iter() {
                    if key == &amp;addr {
                        continue;
                    }

                    match sender_in_map.send(format!(&quot;[{}]: {}&quot;, addr, msg)) {
                        Ok(_) =&gt; {}
                        Err(e) =&gt; println!(&quot;{}&quot;, e),
                    }
                }
                true
            }
            Err(e) =&gt; {
                println!(&quot;{:?}&quot;, e);
                true
            }
        } {}
    });

    for stream in listener.incoming() {
        let sender_agent_copy = sender_agent.clone();
        let (sender_in_map, recv) = channel();
        match stream {
            Ok(mut stream) =&gt; {
                let peer_addr = stream.peer_addr().unwrap();
                println!(&quot;New connection: {}&quot;, peer_addr);
                stream
                    .write(format!(&quot;Welcome {}\n&quot;, peer_addr).as_bytes())
                    .unwrap();

                let sender_map_copy = sender_map.clone();
                sender_map_copy
                    .lock()
                    .unwrap()
                    .insert(peer_addr.clone(), sender_in_map.clone());
                thread::spawn(move || {
                    // connection succeeded
                    handle_client(stream, sender_agent_copy, recv, peer_addr, sender_map_copy)
                });
            }
            Err(e) =&gt; {
                println!(&quot;Error: {}&quot;, e);
                /* connection failed */
            }
        }
    }
    // close the socket server
    drop(listener);
}
</code></pre></pre>
<h1 id="some-markdown-tips"><a class="header" href="#some-markdown-tips">Some Markdown Tips</a></h1>
<p>Simply write sub topics here.</p>
<p>Did you know that you can write math equations here like this?</p>
<p>\[ \mu = \frac{1}{N} \sum_{i=0} x_i \]</p>
<p>The Master Method
\[ 
\begin{align}
\text{If }  \quad  T(n) &amp; &lt;= a T (\frac{n}{b}) + O(n^d) \\ 
\text{Then } \quad  T(n) &amp; =
\begin{cases}
O(n^d \log n)       &amp; \quad \text{if } a = b^d \text{ (Case 1)} \\
O(n^d)              &amp; \quad \text{if } a &lt; b^d \text{ (Case 2)} \\
O(n^{\log_{b}{a} }) &amp; \quad \text{if } a &gt; b^d \text{ (Case 3)}
\end{cases}
\end{align}
\]</p>
<p>Looks pretty awesome. More info see <a href="https://rust-lang.github.io/mdBook/format/mathjax.html">here</a></p>
<h3 id="add-a-table"><a class="header" href="#add-a-table">Add a table</a></h3>
<pre><code>|name   | length|
|----   |:-----:|
|oarfish| 10m?  |
</code></pre>
<table><thead><tr><th>name</th><th align="center">length</th></tr></thead><tbody>
<tr><td>oarfish</td><td align="center">10m?</td></tr>
</tbody></table>
<h3 id="add-a-image"><a class="header" href="#add-a-image">Add a image</a></h3>
<p>You can sort of use github issue page to store some pictures perhaps?</p>
<pre><code>![image](https://user-images.githubusercontent.com/161689/111823245-02280e80-88e5-11eb-849d-b4d1e29c76ce.png)
</code></pre>
<h3 id="hidden-session"><a class="header" href="#hidden-session">Hidden session</a></h3>
<p>And a hidden session like this to hide a graph:</p>
<pre><code class="language-html">&lt;details&gt;
&lt;summary&gt;Some hidden stuff here&lt;/summary&gt;

![image](https://user-images.githubusercontent.com/161689/111823245-02280e80-88e5-11eb-849d-b4d1e29c76ce.png)

&lt;/details&gt;
</code></pre>
<details>
<summary>Some hidden code here</summary>
<img src="https://user-images.githubusercontent.com/161689/111823245-02280e80-88e5-11eb-849d-b4d1e29c76ce.png" width="640" />
</details>
<h3 id="embed-an-youtube-video-like-this"><a class="header" href="#embed-an-youtube-video-like-this">Embed an YouTube Video like this:</a></h3>
<pre><code class="language-html">&lt;iframe width=&quot;640&quot; height=&quot;360&quot; 
    src=&quot;https://www.youtube.com/embed/WbzNRTTrX0g?t=1557&quot; 
    frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write;
    encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;
&lt;/iframe&gt;
</code></pre>
<h3 id="mermaid-graphs"><a class="header" href="#mermaid-graphs">Mermaid graphs</a></h3>
<p>See <a href="https://mermaid-js.github.io/mermaid-live-editor/">here</a>
and <a href="https://github.com/badboy/mdbook-mermaid">here</a>.</p>
<pre><code>```mermaid
graph TD
    A[Christmas] --&gt;|Get money| B(Go shopping)
    B --&gt; C{Let me think}
    C --&gt;|One| D[Laptop]
    C --&gt;|Two| E[iPhone]
    C --&gt;|Three| F[fa:fa-car Car]
```
</code></pre>
<p>gives:</p>
<pre class="mermaid">graph TD
    A[Christmas] --&gt;|Get money| B(Go shopping)
    B --&gt; C{Let me think}
    C --&gt;|One| D[Laptop]
    C --&gt;|Two| E[iPhone]
    C --&gt;|Three| F[fa:fa-car Car]
</pre>
<h1 id="life-tips"><a class="header" href="#life-tips">Life tips</a></h1>
<h2 id="morning-tips"><a class="header" href="#morning-tips">Morning tips</a></h2>
<ul>
<li>Most important time is the 1 hour in the morning</li>
<li>Make bed</li>
<li>Meditation 10-20m, draw attention back to breath, 7 days will have effect?</li>
<li>Tune into the peak state -&gt; &quot;I can do it mode&quot;
<ul>
<li>code shower?</li>
<li>4:16:8 breath exercise</li>
<li>short exercise, or a walk outside</li>
<li>5 - 10 daily journal</li>
</ul>
</li>
</ul>
<h2 id="evening-tips"><a class="header" href="#evening-tips">Evening tips</a></h2>
<ul>
<li>Summary daily journal
<ul>
<li>old/new relationships that helped you</li>
<li>an opportunity recently, (call parents, or work)</li>
<li>something great happened or learned today/yesterday</li>
<li>something simple</li>
</ul>
</li>
</ul>
<p>Ref <a href="https://www.youtube.com/watch?v=XXGINjJzwZs">here</a>, <a href="https://www.youtube.com/watch?v=evXi0G3dVEQ">here</a>.</p>
<h2 id="拖延症"><a class="header" href="#拖延症">拖延症</a></h2>
<ol>
<li>从低期待开始</li>
<li>寻找成就感</li>
<li>设定期限</li>
<li>远离干扰</li>
</ol>
<blockquote>
<p>不管你面对的事情有多么困难，你有多抵触，多害怕，都不要逃避，因为没人能帮你做。而且往往你只需要迈出那第一步，剩下的第二步、第三步、第四步，都比你想象地要轻松很多</p>
</blockquote>
<h2 id="health-tips"><a class="header" href="#health-tips">Health tips</a></h2>
<ul>
<li>Do more sports</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="mermaid.min.js"></script>
        
        <script type="text/javascript" src="mermaid-init.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
